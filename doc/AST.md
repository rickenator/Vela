\
<!-- filepath: /home/rick/Projects/Vyn/doc/AST.md -->
# Vyn AST Design Document

## 1. Introduction

This document outlines the design for the Abstract Syntax Tree (AST) for the Vyn programming language, reflecting the current implementation in `include/vyn/ast.hpp` and `src/ast.cpp`. The AST is a crucial intermediate representation of the source code, generated by the parser. It serves as the primary data structure for subsequent compilation phases, including semantic analysis, type checking, optimization, and code generation.

The AST faithfully represents the syntactic structure of the Vyn code.

## 2. Core AST Node Design

All AST nodes inherit from a base `Node` class.

```cpp
// Structure in include/vyn/ast.hpp
namespace Vyn::AST {

// Forward declarations for all AST node types and Visitor
// (Many forward declarations exist in ast.hpp such as IntLiteralNode, BinaryOpNode, etc.)

struct SourceLocation {
    std::string filePath;
    int line;
    int column;

    SourceLocation(std::string fp = \"\", int l = 0, int c = 0);
};

enum class NodeType {
    // Literals & Basic
    IDENTIFIER,
    PATH,
    INT_LITERAL,
    FLOAT_LITERAL,
    STRING_LITERAL,
    BOOL_LITERAL,
    CHAR_LITERAL, // Added
    NULL_LITERAL, // Added

    // Expressions
    UNARY_OP,
    BINARY_OP,
    CALL_EXPR,
    ARRAY_ACCESS,
    MEMBER_ACCESS,
    ASSIGNMENT,
    TUPLE_LITERAL,
    STRUCT_LITERAL,
    ENUM_LITERAL,

    // Statements
    EXPRESSION_STMT,
    BLOCK_STMT,
    VAR_DECL_STMT,
    IF_STMT,
    FOR_STMT,
    WHILE_STMT,
    RETURN_STMT,
    BREAK_STMT,
    CONTINUE_STMT,

    // Declarations
    FUNC_DECL,
    PARAM,
    STRUCT_DECL,
    CLASS_DECL, // Added
    FIELD_DECL, // Added (for class/struct members)
    IMPL_DECL,
    GENERIC_PARAM,
    ENUM_DECL,      // Added
    ENUM_VARIANT,   // Added
    TYPE_ALIAS_DECL, // Added
    GLOBAL_VAR_DECL, // Added

    // Types
    TYPE_NAME, // Conceptual type, IdentifierTypeNode is a concrete usage
    ARRAY_TYPE,
    POINTER_TYPE,
    OPTIONAL_TYPE,

    // Patterns
    IDENTIFIER_PATTERN,
    LITERAL_PATTERN,
    WILDCARD_PATTERN,
    TUPLE_PATTERN,
    ENUM_VARIANT_PATTERN,
    STRUCT_PATTERN, // Corrected: Was previously noted as missing

    // Module
    MODULE,

    // Base/Abstract types
    NODE,
    EXPR_NODE,
    STMT_NODE,
    DECL_NODE,
    TYPE_NODE,
    PATTERN_NODE
};

class Node {
public:
    NodeType type;
    SourceLocation location;
    Node* parent;

    Node(NodeType t, SourceLocation loc, Node* p = nullptr);
    virtual ~Node() = default;
    virtual void accept(Visitor& visitor) = 0; // Pure virtual
    virtual std::string toString(int indent = 0) const = 0; // Pure virtual
};

// Intermediate base classes
class ExprNode : public Node {
public:
    ExprNode(NodeType t, SourceLocation loc, Node* p = nullptr);
    // accept and toString are pure virtual, inherited from Node
};

class StmtNode : public Node {
public:
    StmtNode(NodeType t, SourceLocation loc, Node* p = nullptr);
    // accept and toString are pure virtual, inherited from Node
};

class DeclNode : public Node {
public:
    DeclNode(NodeType t, SourceLocation loc, Node* p = nullptr);
    // accept and toString are pure virtual, inherited from Node
};

class TypeNode : public Node {
public:
    TypeNode(NodeType t, SourceLocation loc, Node* p = nullptr);
    // accept and toString are pure virtual, inherited from Node
};

class PatternNode : public Node {
public:
    PatternNode(NodeType t, SourceLocation loc, Node* p = nullptr);
    // accept and toString are pure virtual, inherited from Node
};

} // namespace Vyn::AST
```

-   **`SourceLocation`**: Stores filename, line, and column for error messages and debugging.
-   **`NodeType`**: Enum to identify the specific type of the node. (See "Open Questions" regarding `STRUCT_PATTERN`).
-   **`parent`**: Optional pointer to the parent node.
-   **`accept(Visitor&)`**: Pure virtual method for implementing the Visitor design pattern.
-   **`toString()`**: Pure virtual method for debugging and pretty-printing the AST.
-   **Intermediate Base Classes**: `ExprNode`, `StmtNode`, `DeclNode`, `TypeNode`, `PatternNode` provide common bases for categories of nodes.

## 3. Path Node

A `PathNode` represents a qualified name, such as `module::submodule::Item`. It can be part of a Type, Expression, or Pattern.

-   **`PathNode : Node`**:
    -   `std::vector<std::unique_ptr<IdentifierNode>> segments;`
    -   `// bool is_absolute; // Optional: for paths like ::foo::bar`

## 4. Expression Nodes

Derived from `ExprNode : Node`.

-   **`IdentifierNode : ExprNode`**: Represents an identifier.
    -   `std::string name;`
-   **Literal Nodes**:
    -   **`IntLiteralNode : ExprNode`**: (Assumed structure based on `NodeType::INT_LITERAL` and Visitor)
        -   `long long value;`
    -   **`FloatLiteralNode : ExprNode`**: (Assumed structure based on `NodeType::FLOAT_LITERAL` and Visitor)
        -   `double value;`
    -   **`StringLiteralNode : ExprNode`**: (Assumed structure based on `NodeType::STRING_LITERAL` and Visitor)
        -   `std::string value;`
    -   **`BoolLiteralNode : ExprNode`**: (Assumed structure based on `NodeType::BOOL_LITERAL` and Visitor)
        -   `bool value;`
    -   **`CharLiteralNode : ExprNode`**: (Assumed structure based on `NodeType::CHAR_LITERAL` and Visitor)
        -   `char value;`
    -   **`NullLiteralNode : ExprNode`**: (Assumed structure based on `NodeType::NULL_LITERAL` and Visitor)
-   **`TupleLiteralNode : ExprNode`**: Represents a tuple literal, e.g., `(1, "hello")`.
    -   `std::vector<std::unique_ptr<ExprNode>> elements;`
-   **`StructLiteralNode : ExprNode`**: Represents a struct instantiation, e.g., `MyStruct { field1: value1, field2: value2 }`.
    -   `std::unique_ptr<TypeNode> type;` (e.g., `IdentifierTypeNode` for `MyStruct`)
    -   `std::vector<StructLiteralField> fields;`
    -   **`StructLiteralField`** (Helper struct, not an AST `Node`):
        -   `SourceLocation location;`
        -   `std::unique_ptr<IdentifierNode> name;`
        -   `std::unique_ptr<ExprNode> value;`
-   **`EnumLiteralNode : ExprNode`**: Represents an enum variant instantiation, e.g., `MyEnum::Variant(arg1)`.
    -   `std::unique_ptr<PathNode> path;` (e.g., for `MyEnum::Variant`)
    -   `std::vector<std::unique_ptr<ExprNode>> arguments;`
-   **Operator Nodes**:
    -   **`UnaryOpNode : ExprNode`**: (Assumed structure based on `NodeType::UNARY_OP` and Visitor)
        -   `Vyn::TokenType operatorType;` (e.g., `MINUS`, `NOT`)
        -   `std::unique_ptr<ExprNode> operand;`
    -   **`BinaryOpNode : ExprNode`**: (Assumed structure based on `NodeType::BINARY_OP` and Visitor)
        -   `Vyn::TokenType operatorType;` (e.g., `PLUS`, `EQUAL_EQUAL`)
        -   `std::unique_ptr<ExprNode> leftOperand;`
        -   `std::unique_ptr<ExprNode> rightOperand;`
-   **`CallExprNode : ExprNode`**: Represents a function or method call. (Assumed structure based on `NodeType::CALL_EXPR` and Visitor)
    -   `std::unique_ptr<ExprNode> callee;` (e.g., `IdentifierNode`, `MemberAccessNode`)
    -   `std::vector<std::unique_ptr<ExprNode>> arguments;`
-   **`ArrayAccessNode : ExprNode`**: Represents an array indexing operation, e.g., `arr[index]`. (Assumed structure based on `NodeType::ARRAY_ACCESS` and Visitor)
    -   `std::unique_ptr<ExprNode> array;` (Expression being indexed)
    -   `std::unique_ptr<ExprNode> index;` (Index expression)
-   **`MemberAccessNode : ExprNode`**: Represents accessing a member of a struct or object, e.g., `obj.member`. (Assumed structure based on `NodeType::MEMBER_ACCESS` and Visitor)
    -   `std::unique_ptr<ExprNode> object;`
    -   `std::unique_ptr<IdentifierNode> member;`
-   **`AssignmentNode : ExprNode`**: Represents an assignment operation, e.g., `variable = value`. (Assumed structure based on `NodeType::ASSIGNMENT` and Visitor)
    -   `std::unique_ptr<ExprNode> left;` (L-value expression)
    -   `std::unique_ptr<ExprNode> right;` (R-value expression)

## 5. Statement Nodes

Derived from `StmtNode : Node`.

-   **`ExpressionStmtNode : StmtNode`**: Wraps an expression used as a statement. (Assumed structure based on `NodeType::EXPRESSION_STMT` and Visitor)
    -   `std::unique_ptr<ExprNode> expression;`
-   **`BlockStmtNode : StmtNode`**: Represents a block of statements, e.g., `{ stmt1; stmt2; }`. (Assumed structure based on `NodeType::BLOCK_STMT` and Visitor)
    -   `std::vector<std::unique_ptr<StmtNode>> statements;`
-   **`VarDeclStmtNode : StmtNode`**: Represents a variable declaration, e.g., `var x: int = 10;` or `var (a, b) = (1, 2);`.
    -   `std::unique_ptr<PatternNode> pattern;` (The pattern being declared, e.g., `IdentifierPatternNode`, `TuplePatternNode`)
    -   `std::unique_ptr<TypeNode> typeAnnotation;` // Optional
    -   `std::unique_ptr<ExprNode> initializer;` // Optional
    -   `bool isMut;` // Reflects 'var' (true) or 'let' (false)
-   **`IfStmtNode : StmtNode`**: Represents an if-else statement. (Assumed structure based on `NodeType::IF_STMT` and Visitor)
    -   `std::unique_ptr<ExprNode> condition;`
    -   `std::unique_ptr<BlockStmtNode> thenBlock;`
    -   `std::unique_ptr<Node> elseBranch;` // Can be `BlockStmtNode` or another `IfStmtNode` (for else if)
-   **`WhileStmtNode : StmtNode`**: Represents a while loop. (Assumed structure based on `NodeType::WHILE_STMT` and Visitor)
    -   `std::unique_ptr<ExprNode> condition;`
    -   `std::unique_ptr<BlockStmtNode> body;`
-   **`ForStmtNode : StmtNode`**: Represents a for loop (e.g., for-in loop). (Assumed structure based on `NodeType::FOR_STMT` and Visitor)
    -   `std::unique_ptr<PatternNode> pattern;` (Variable or pattern to bind)
    -   `std::unique_ptr<ExprNode> iterable;`
    -   `std::unique_ptr<BlockStmtNode> body;`
-   **`ReturnStmtNode : StmtNode`**: Represents a return statement. (Assumed structure based on `NodeType::RETURN_STMT` and Visitor)
    -   `std::unique_ptr<ExprNode> value;` // Optional
-   **`BreakStmtNode : StmtNode`**: Represents a break statement. (Assumed structure based on `NodeType::BREAK_STMT` and Visitor)
-   **`ContinueStmtNode : StmtNode`**: Represents a continue statement. (Assumed structure based on `NodeType::CONTINUE_STMT` and Visitor)

## 6. Declaration Nodes

Derived from `DeclNode : Node`.

-   **`GenericParamNode : Node`**: Represents a generic parameter in a declaration, e.g., `T: Trait1 + Trait2`.
    -   `std::unique_ptr<IdentifierNode> name;`
    -   `std::vector<std::unique_ptr<TypeNode>> trait_bounds;`
-   **`ParamNode : DeclNode`**: Represents a parameter in a function declaration.
    -   `std::unique_ptr<IdentifierNode> name;`
    -   `std::unique_ptr<TypeNode> type;`
    -   `// bool isMutable; // Potentially for 'mut name: Type'`
    -   `// bool isRef; // For reference parameters`
-   **`FuncDeclNode : DeclNode`**: Represents a function declaration.
    -   `std::unique_ptr<IdentifierNode> name;`
    -   `std::vector<std::unique_ptr<GenericParamNode>> generic_params;`
    -   `std::vector<std::unique_ptr<ParamNode>> params;`
    -   `std::unique_ptr<TypeNode> return_type;` // Optional
    -   `std::unique_ptr<BlockStmtNode> body;` // Optional (for external/interface functions)
    -   `// bool is_async;`
    -   `// bool is_extern;`
-   **`StructDeclNode : DeclNode`**: Represents a struct declaration.
    -   `std::unique_ptr<IdentifierNode> name;`
    -   `std::vector<std::unique_ptr<GenericParamNode>> generic_params;`
    -   `std::vector<std::pair<std::unique_ptr<IdentifierNode>, std::unique_ptr<TypeNode>>> fields;` // Corrected to match ast.hpp
-   **`FieldDeclNode : DeclNode`**: Represents a field declaration within a class (or potentially struct in the future).
    -   `std::unique_ptr<IdentifierNode> name;`
    -   `std::unique_ptr<TypeNode> type_annotation;` // Mandatory for fields
    -   `std::unique_ptr<ExprNode> initializer;`     // Optional
    -   `bool is_mutable;`                           // true for 'var', false for 'let'/'const'
-   **`ClassDeclNode : DeclNode`**: Represents a class declaration.
    -   `std::unique_ptr<IdentifierNode> name;`
    -   `std::vector<std::unique_ptr<GenericParamNode>> generic_params;`
    -   `std::vector<std::unique_ptr<DeclNode>> members;` // Can be `FieldDeclNode` or `FuncDeclNode`
-   **`ImplDeclNode : DeclNode`**: Represents an implementation block for a struct or class.
    -   `std::vector<std::unique_ptr<GenericParamNode>> generic_params;`
    -   `std::unique_ptr<TypeNode> self_type;` (The type being implemented)
    -   `std::unique_ptr<TypeNode> trait_type;` // Optional: if implementing a trait
    -   `std::vector<std::unique_ptr<FuncDeclNode>> methods;`
-   **`EnumVariantNode : Node`**: Represents a variant within an enum declaration (e.g., `Some(T)` in `enum Option<T> { Some(T), None }`).
    -   `std::unique_ptr<IdentifierNode> name;`
    -   `std::vector<std::unique_ptr<TypeNode>> types;` // For tuple-like parameters, e.g., `Variant(Type1, Type2)`.
-   **`EnumDeclNode : DeclNode`**: Represents an enum declaration.
    -   `std::unique_ptr<IdentifierNode> name;`
    -   `std::vector<std::unique_ptr<GenericParamNode>> generic_params;`
    -   `std::vector<std::unique_ptr<EnumVariantNode>> variants;`
-   **`TypeAliasDeclNode : DeclNode`**: Represents a type alias declaration, e.g., `type MyInt<T> = T;`.
    -   `std::unique_ptr<IdentifierNode> name;`
    -   `std::vector<std::unique_ptr<GenericParamNode>> generic_params;`
    -   `std::unique_ptr<TypeNode> aliased_type;`

-   **`GlobalVarDeclNode : DeclNode`**: Represents a global variable declaration, e.g., `let x: int = 10;`, `var y = "hello";`, `const Z = 3.14;`.
    -   `std::unique_ptr<PatternNode> pattern;` (The pattern being declared, e.g., `IdentifierPatternNode` for `x`, `y`, `Z`)
    -   `std::unique_ptr<TypeNode> type_annotation;` // Optional
    -   `std::unique_ptr<ExprNode> initializer;`     // Optional (but usually present for `const` and often for `let`/`var`)
    -   `bool is_mutable;`                           // `true` for `var`, `false` for `let`
    -   `bool is_const;`                             // `true` for `const`

## 7. Type Nodes

Derived from `TypeNode : Node`.

-   **`IdentifierTypeNode : TypeNode`**: Represents a named type, possibly qualified, e.g., `MyType`, `collections::List`.
    -   `std::unique_ptr<PathNode> path;`
-   **`ArrayTypeNode : TypeNode`**: Represents an array type, e.g., `[int; 5]` or `[string]`. (Assumed structure based on `NodeType::ARRAY_TYPE` and Visitor)
    -   `std::unique_ptr<TypeNode> element_type;`
    -   `std::unique_ptr<ExprNode> size;` // Optional
-   **`PointerTypeNode : TypeNode`**: Represents a pointer type, e.g., `*int`, `*mut string`. (Assumed structure based on `NodeType::POINTER_TYPE` and Visitor)
    -   `std::unique_ptr<TypeNode> element_type;`
    -   `bool is_mutable;`
-   **`OptionalTypeNode : TypeNode`**: Represents an optional type, e.g., `?int`. (Assumed structure based on `NodeType::OPTIONAL_TYPE` and Visitor)
    -   `std::unique_ptr<TypeNode> element_type;`

## 8. Pattern Nodes

Derived from `PatternNode : Node`. Used in `VarDeclStmtNode`, `ForStmtNode`, and potentially match expressions in the future.

-   **`IdentifierPatternNode : PatternNode`**: Binds a value to an identifier, e.g., `x` in `var x = ...`.
    -   `std::unique_ptr<IdentifierNode> identifier;`
    -   `bool isMutable;` // Added: true if the binding is mutable (e.g. `var mut x` or `var x` where context implies mutability)
-   **`LiteralPatternNode : PatternNode`**: Matches a specific literal value.
    -   `std::unique_ptr<ExprNode> literal;` (e.g., `IntLiteralNode`, `StringLiteralNode`)
-   **`WildcardPatternNode : PatternNode`**: `_`, matches anything without binding.
-   **`TuplePatternNode : PatternNode`**: Matches and destructures a tuple, e.g., `(a, _, c)`.
    -   `std::vector<std::unique_ptr<PatternNode>> elements;`
-   **`EnumVariantPatternNode : PatternNode`**: Matches and destructures an enum variant, e.g., `Option::Some(x)`.
    -   `std::unique_ptr<PathNode> path;` (For `Option::Some`)
    -   `std::vector<std::unique_ptr<PatternNode>> arguments;` (For `x`)
-   **`StructPatternNode : PatternNode`**: Matches and destructures a struct, e.g., `Point { x: 0, y }`.
    -   `std::unique_ptr<PathNode> struct_path;` // Updated: Name/path of the struct (e.g., "Point" or "my::Point").
    -   `std::vector<StructPatternField> fields;`
    -   `// bool has_rest_pattern; // For .. syntax`
    -   **`StructPatternField`** (Helper struct, not an AST `Node`):
        -   `SourceLocation location;`
        -   `std::unique_ptr<IdentifierNode> name;` // Changed from std::string field_name
        -   `std::unique_ptr<PatternNode> pattern;` // Optional: if null, shorthand for field_name: field_name

## 9. Module Node

The root of the AST for a single source file.

-   **`ModuleNode : Node`**: (Assumed structure based on `NodeType::MODULE` and Visitor)
    -   `std::string file_path;`
    -   `std::vector<std::unique_ptr<DeclNode>> declarations;`
    -   `// Potentially other module-level items like imports`

## 10. AST Traversal and Manipulation (Visitor)

The Visitor pattern is used for operating on the AST. Each concrete AST node has an `accept(Visitor& visitor)` method.

```cpp
// Visitor interface in include/vyn/ast.hpp
namespace Vyn::AST {

class Visitor {
public:
    virtual ~Visitor() = default;

    // Expressions
    virtual void visit(IdentifierNode* node) = 0;
    virtual void visit(PathNode* node) = 0;
    virtual void visit(IntLiteralNode* node) = 0;
    virtual void visit(FloatLiteralNode* node) = 0;
    virtual void visit(StringLiteralNode* node) = 0;
    virtual void visit(BoolLiteralNode* node) = 0;
    virtual void visit(BinaryOpNode* node) = 0;
    virtual void visit(UnaryOpNode* node) = 0;
    virtual void visit(CallExprNode* node) = 0;
    virtual void visit(ArrayAccessNode* node) = 0;
    virtual void visit(MemberAccessNode* node) = 0;
    virtual void visit(AssignmentNode* node) = 0;
    virtual void visit(TupleLiteralNode* node) = 0;
    virtual void visit(StructLiteralNode* node) = 0;
    virtual void visit(EnumLiteralNode* node) = 0;

    // Statements
    virtual void visit(BlockStmtNode* node) = 0;
    virtual void visit(ReturnStmtNode* node) = 0;
    virtual void visit(IfStmtNode* node) = 0;
    virtual void visit(ExpressionStmtNode* node) = 0;
    virtual void visit(VarDeclStmtNode* node) = 0;
    virtual void visit(WhileStmtNode* node) = 0;
    virtual void visit(ForStmtNode* node) = 0;
    virtual void visit(BreakStmtNode* node) = 0;
    virtual void visit(ContinueStmtNode* node) = 0;

    // Declarations
    virtual void visit(ParamNode* node) = 0;
    virtual void visit(FuncDeclNode* node) = 0;
    virtual void visit(StructDeclNode* node) = 0;
    virtual void visit(FieldDeclNode* node) = 0; // Added
    virtual void visit(ClassDeclNode* node) = 0; // Added
    virtual void visit(ImplDeclNode* node) = 0;
    virtual void visit(GenericParamNode* node) = 0;
    virtual void visit(EnumVariantNode* node) = 0; // Added
    virtual void visit(EnumDeclNode* node) = 0;   // Added
    virtual void visit(TypeAliasDeclNode* node) = 0; // Added
    virtual void visit(GlobalVarDeclNode* node) = 0; // Added

    // Types
    // virtual void visit(TypeNameNode* node) = 0; // If TypeNameNode is used distinctly
    virtual void visit(IdentifierTypeNode* node) = 0;
    virtual void visit(ArrayTypeNode* node) = 0;
    virtual void visit(PointerTypeNode* node) = 0;
    virtual void visit(OptionalTypeNode* node) = 0;

    // Patterns
    virtual void visit(IdentifierPatternNode* node) = 0;
    virtual void visit(LiteralPatternNode* node) = 0;
    virtual void visit(WildcardPatternNode* node) = 0;
    virtual void visit(TuplePatternNode* node) = 0;
    virtual void visit(EnumVariantPatternNode* node) = 0;
    virtual void visit(StructPatternNode* node) = 0;

    // Module
    virtual void visit(ModuleNode* node) = 0;
};

// Each concrete Node type implements:
// void accept(Visitor& visitor) override { visitor.visit(this); }
// (where \'this\' is cast to the concrete type for dispatch)

} // namespace Vyn::AST
```

## 11. Integration with Existing Parser

The parser components (`BaseParser`, `DeclarationParser`, `ExpressionParser`, `StatementParser`, etc.) are responsible for constructing instances of these AST nodes. `std::unique_ptr` is used for ownership, with the `ModuleNode` ultimately owning all nodes for a file. `SourceLocation` is set by the parser for each node.

## 12. Future Considerations

-   **Macros**: Could be `MacroInvocationNode`, expanding to standard AST nodes.
-   **Annotations/Attributes**: Could be `AnnotationNode` attached to declarable nodes.
-   **Error Handling**: Robust strategies for partial ASTs or error nodes during parsing.
-   **Enum Declarations**: Full support for `enum Name { Variant1(Type), ... }` declarations (currently only enum literals and patterns are supported).
-   **Match Expressions/Statements**: Full support using the defined pattern nodes.
-   **Import/Smuggle Statements**: Nodes for module system interactions.
-   **Other Literal Types**: `CharLiteralNode`, `RuneLiteralNode`, `BytesLiteralNode`, `NilLiteralNode` if they are added to the language.
-   **Other Expression Types**: `IfExprNode`, `ListComprehensionNode`, `AwaitExprNode` if added.
-   **Other Statement Types**: `ConstDeclNode`, `DeferStmtNode`, `TryStmtNode`, `MatchStmtNode` if added.

## 13. Open Questions & Discussion Points

-   **Error Handling during AST Construction**: How should the parser signal unrecoverable syntax errors? Current approach involves throwing exceptions, but alternatives like error nodes or partial ASTs could be considered.
-   **Completeness of `ast.hpp` Snippet**: The provided `ast.hpp` in context primarily shows forward declarations and visitor methods for many nodes. This document assumes their member structures based on common practices and their `NodeType`. Full definitions in `ast.hpp` would be beneficial for precise documentation.
-   **Struct Field Mutability**: `StructDeclNode` fields currently only store name and type. Mutability of struct fields is typically handled by the mutability of the struct instance itself (e.g. `let s = MyStruct(); s.field = ...` would be an error if fields are not inherently mutable or `s` is not `var`). This might need further clarification in the language design.
-   **Enum Declarations**: Full support for `enum Name { Variant1(Type), ... }` declarations is still pending. -> **Implemented.**
-   **`ParamNode` details**: `ParamNode` in `ast.hpp` has `isRef` and `isMut` which are not yet fully reflected in this document's `ParamNode` description.

This document reflects the AST structure as per the latest understanding of `ast.hpp` and `ast.cpp` implementations. It should be updated as the language and its AST evolve.
