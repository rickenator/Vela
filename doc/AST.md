<!-- filepath: /home/rick/Projects/Vyn/doc/AST.md -->
# Vyn AST Design Document

*(Note: This document outlines the design for the Abstract Syntax Tree (AST) for the Vyn programming language. It describes both the features currently implemented in `include/vyn/ast.hpp` and `src/ast.cpp`, and planned features that are not yet implemented. Sections or specific details referring to planned features will be explicitly marked.)*

## 1. Introduction

This document outlines the design for the Abstract Syntax Tree (AST) for the Vyn programming language. The AST is a crucial intermediate representation of the source code, generated by the parser. It serves as the primary data structure for subsequent compilation phases, including semantic analysis, type checking, optimization, and code generation.

The AST aims to faithfully represent the syntactic structure of the Vyn code, encompassing both current capabilities and future language extensions.

## 2. Core AST Node Design

All AST nodes inherit from a base `Node` class as defined in `include/vyn/ast.hpp`.

```cpp
// Structure in include/vyn/ast.hpp
namespace vyn { // Adjusted to 'vyn' namespace as in ast.hpp

// Forward declarations for Visitor pattern (from ast.hpp)
class Node;
class Expression;
class Statement;
class Declaration;
class Visitor;
class StructDeclaration;
class ClassDeclaration;
class FieldDeclaration;
class ImplDeclaration;
class EnumDeclaration;
class EnumVariantNode;
class GenericParamNode;
class TypeAnnotation; // Added: Forward declaration for TypeAnnotation
class Module;         // Added: Forward declaration for Module

// SourceLocation is defined in "vyn/source_location.hpp"
// struct SourceLocation {
//     std::string filePath; // Conceptual representation
//     int line;
//     int column;
// };

// NodeType enum as defined in ast.hpp
enum class NodeType {
    // Literals
    IDENTIFIER,
    INTEGER_LITERAL,
    FLOAT_LITERAL,
    STRING_LITERAL,
    BOOLEAN_LITERAL,
    ARRAY_LITERAL,    // Implemented
    OBJECT_LITERAL,   // Implemented

    // Expressions
    UNARY_EXPRESSION,
    BINARY_EXPRESSION,
    CALL_EXPRESSION,
    MEMBER_EXPRESSION,
    ASSIGNMENT_EXPRESSION,

    // Statements
    BLOCK_STATEMENT,
    EXPRESSION_STATEMENT,
    IF_STATEMENT,
    FOR_STATEMENT,
    WHILE_STATEMENT,
    RETURN_STATEMENT,
    BREAK_STATEMENT,
    CONTINUE_STATEMENT,

    // Declarations
    VARIABLE_DECLARATION,
    FUNCTION_DECLARATION,
    TYPE_ALIAS_DECLARATION,
    IMPORT_DECLARATION,
    STRUCT_DECLARATION,
    CLASS_DECLARATION,
    FIELD_DECLARATION,
    IMPL_DECLARATION,
    ENUM_DECLARATION,
    ENUM_VARIANT,
    GENERIC_PARAMETER,

    // Other
    TYPE_ANNOTATION,
    MODULE
};

// Base AST Node (matches ast.hpp)
class Node {
public:
    SourceLocation loc; // From vyn::source_location.hpp

    Node(SourceLocation loc);
    virtual ~Node() = default;
    virtual NodeType getType() const = 0;
    virtual std::string toString() const = 0;
    virtual void accept(Visitor& visitor) = 0;
    // Note: 'parent' pointer is not part of the current C++ Node class.
};

// Base Expression Node (matches ast.hpp)
class Expression : public Node {
public:
    Expression(SourceLocation loc);
};

// Base Statement Node (matches ast.hpp)
class Statement : public Node {
public:
    Statement(SourceLocation loc);
};

// Base Declaration Node (matches ast.hpp, Declarations are Statements)
class Declaration : public Statement {
public:
    Declaration(SourceLocation loc);
};

// Conceptual base classes from original design (Not directly in C++ hierarchy this way)
// class TypeNode : public Node { /* ... */ }; // *(Note: This specific base class is conceptual; TypeAnnotation is the implemented type representation.)*
// class PatternNode : public Node { /* ... */ }; // *(Note: This base class and Pattern nodes are planned and not yet implemented.)*

} // namespace vyn
```

-   **`vyn::SourceLocation`**: Defined in `vyn/source_location.hpp`. Stores filename, line, and column.
-   **`vyn::NodeType`**: Enum to identify the specific type of the node, reflecting the current C++ implementation.
-   **`vyn::Node::loc`**: The source location of the node.
-   **`vyn::Node::getType()`**: Returns the `NodeType` of the node.
-   **`vyn::Node::accept(Visitor&)`**: Pure virtual method for the Visitor pattern.
-   **`vyn::Node::toString()`**: Pure virtual method for debugging.
-   **Implemented Base Classes**: `vyn::Expression`, `vyn::Statement`, `vyn::Declaration` (which inherits from `Statement`).
-   **Planned Node Categories**: `TypeNode` and `PatternNode` represent categories of nodes that are part of the broader language design but are not yet implemented as specific base classes in C++ or have limited/different representation (e.g. `TypeAnnotation` for types).

## 3. Path Node
*(Note: `PathNode` and its related features are planned and not yet implemented.)*

A `PathNode` represents a qualified name, such as `module::submodule::Item`. It can be part of a Type, Expression, or Pattern.

-   **`PathNode : Node`** (Conceptual):
    -   `std::vector<std::unique_ptr<IdentifierNode>> segments;`
    -   `// bool is_absolute; // Optional: for paths like ::foo::bar`

## 4. Expression Nodes

Derived from `vyn::Expression : vyn::Node`.

-   **`vyn::Identifier : vyn::Expression`**: Represents an identifier. (Matches C++ `Identifier`)
    -   `std::string name;`
-   **Literal Nodes**:
    -   **`vyn::IntegerLiteral : vyn::Expression`**: (Matches C++ `IntegerLiteral`)
        -   `int64_t value;`
    -   **`vyn::FloatLiteral : vyn::Expression`**: (Matches C++ `FloatLiteral`)
        -   `double value;`
    -   **`vyn::StringLiteral : vyn::Expression`**: (Matches C++ `StringLiteral`)
        -   `std::string value;`
    -   **`vyn::BooleanLiteral : vyn::Expression`**: (Matches C++ `BooleanLiteral`)
        -   `bool value;`
    -   **`vyn::ArrayLiteral : vyn::Expression`**: Represents an array literal e.g. `[1, 2, 3]`. (Matches C++ `ArrayLiteral`)
        -   `std::vector<std::unique_ptr<vyn::Expression>> elements;`
    -   **`vyn::ObjectLiteral : vyn::Expression`**: Represents an object literal e.g. `{key1: val1, key2: val2}`. (Matches C++ `ObjectLiteral`)
        -   `std::vector<vyn::ObjectProperty> properties;`
        -   **`vyn::ObjectProperty`** (Helper struct, matches C++):
            -   `vyn::SourceLocation loc;`
            -   `std::unique_ptr<vyn::Identifier> key;`
            -   `std::unique_ptr<vyn::Expression> value;`
    -   **`CharLiteralNode : ExprNode`**: *(Note: This node is planned and not yet implemented.)*
        -   `char value;`
    -   **`NullLiteralNode : ExprNode`**: *(Note: This node is planned and not yet implemented.)*
-   **`TupleLiteralNode : ExprNode`**: *(Note: This node is planned and not yet implemented.)*
    -   `std::vector<std::unique_ptr<ExprNode>> elements;`
-   **`StructLiteralNode : ExprNode`**: *(Note: This node is planned and not yet implemented. Current C++ uses `ObjectLiteral` for key-value pairs, which is different from a typed struct instantiation.)*
    -   `std::unique_ptr<TypeNode> type;`
    -   `std::vector<StructLiteralField> fields;`
    -   **`StructLiteralField`** (Helper struct):
        -   `SourceLocation location;`
        -   `std::unique_ptr<IdentifierNode> name;`
        -   `std::unique_ptr<ExprNode> value;`
-   **`EnumLiteralNode : ExprNode`**: *(Note: This node is planned and not yet implemented.)*
    -   `std::unique_ptr<PathNode> path;`
    -   `std::vector<std::unique_ptr<ExprNode>> arguments;`
-   **Operator Nodes**:
    -   **`vyn::UnaryExpression : vyn::Expression`**: (Matches C++ `UnaryExpression`)
        -   `vyn::token::Token op;`
        -   `std::unique_ptr<vyn::Expression> operand;`
    -   **`vyn::BinaryExpression : vyn::Expression`**: (Matches C++ `BinaryExpression`)
        -   `std::unique_ptr<vyn::Expression> left;`
        -   `vyn::token::Token op;`
        -   `std::unique_ptr<vyn::Expression> right;`
-   **`vyn::CallExpression : vyn::Expression`**: Represents a function or method call. (Matches C++ `CallExpression`)
    -   `std::unique_ptr<vyn::Expression> callee;`
    -   `std::vector<std::unique_ptr<vyn::Expression>> arguments;`
-   **`vyn::MemberExpression : vyn::Expression`**: Represents member access (dot or bracket). (Matches C++ `MemberExpression`)
    -   `std::unique_ptr<vyn::Expression> object;`
    -   `std::unique_ptr<vyn::Expression> property;` // Identifier or Expression if computed
    -   `bool computed;` // True for `[]`, false for `.`
    *(Note: This replaces `ArrayAccessNode` and `MemberAccessNode` from the original design with a unified C++ structure.)*
-   **`vyn::AssignmentExpression : vyn::Expression`**: Represents an assignment. (Matches C++ `AssignmentExpression`)
    -   `std::unique_ptr<vyn::Expression> left;`
    -   `vyn::token::Token op;` // e.g., `=`, `+=`
    -   `std::unique_ptr<vyn::Expression> right;`

-   **`AwaitExprNode : ExprNode`**: *(Note: This node is planned and not yet implemented.)*
    -   `std::unique_ptr<ExprNode> expression;`

-   **`IfExprNode : ExprNode`**: *(Note: This node is planned and not yet implemented.)*
    -   `std::unique_ptr<ExprNode> condition;`
    -   `std::unique_ptr<BlockStmtNode> thenBlock;`
    -   `std::unique_ptr<ExprNode> elseExpression;`

-   **`ListComprehensionNode : ExprNode`**: *(Note: This node is planned and not yet implemented.)*
    -   `std::unique_ptr<ExprNode> outputExpression;`
    -   `std::unique_ptr<PatternNode> variablePattern;`
    -   `std::unique_ptr<ExprNode> iterableExpression;`
    -   `std::unique_ptr<ExprNode> filterCondition;`

-   **`MacroInvocationNode : ExprNode`**: *(Note: This node is planned and not yet implemented.)*
    -   `std::unique_ptr<PathNode> path;`
    -   `std::vector<std::unique_ptr<ExprNode>> arguments;`

## 5. Statement Nodes

Derived from `vyn::Statement : vyn::Node`.

-   **`vyn::ExpressionStatement : vyn::Statement`**: Wraps an expression. (Matches C++ `ExpressionStatement`)
    -   `std::unique_ptr<vyn::Expression> expression;`
-   **`vyn::BlockStatement : vyn::Statement`**: Represents a block of statements. (Matches C++ `BlockStatement`)
    -   `std::vector<std::unique_ptr<vyn::Statement>> body;`
-   **`vyn::VariableDeclaration : vyn::Declaration`**: Represents a variable declaration. (Matches C++ `VariableDeclaration`)
    -   `std::unique_ptr<vyn::Identifier> id;`
    -   `bool isConst;`
    -   `std::unique_ptr<vyn::TypeAnnotation> typeAnnotation;` // Optional
    -   `std::unique_ptr<vyn::Expression> init;` // Optional
    *(Note: This replaces `VarDeclStmtNode` which used `PatternNode`. Pattern-based destructuring is a planned feature.)*
-   **`vyn::IfStatement : vyn::Statement`**: Represents an if-else statement. (Matches C++ `IfStatement`)
    -   `std::unique_ptr<vyn::Expression> test;`
    -   `std::unique_ptr<vyn::Statement> consequent;`
    -   `std::unique_ptr<vyn::Statement> alternate;` // Optional
-   **`vyn::WhileStatement : vyn::Statement`**: Represents a while loop. (Matches C++ `WhileStatement`)
    -   `std::unique_ptr<vyn::Expression> test;`
    -   `std::unique_ptr<vyn::Statement> body;`
-   **`vyn::ForStatement : vyn::Statement`**: Represents a C-style for loop. (Matches C++ `ForStatement`)
    -   `std::unique_ptr<vyn::Node> init;`   // VariableDeclaration or ExpressionStatement or nullptr
    -   `std::unique_ptr<vyn::Expression> test;`   // Expression or nullptr
    -   `std::unique_ptr<vyn::Expression> update;` // Expression or nullptr
    -   `std::unique_ptr<vyn::Statement> body;`
    *(Note: The original design's `ForStmtNode` with `PatternNode` and iterable is a planned feature for for-in loops.)*
-   **`vyn::ReturnStatement : vyn::Statement`**: Represents a return statement. (Matches C++ `ReturnStatement`)
    -   `std::unique_ptr<vyn::Expression> argument;` // Optional
-   **`vyn::BreakStatement : vyn::Statement`**: Represents a break statement. (Matches C++ `BreakStatement`)
-   **`vyn::ContinueStatement : vyn::Statement`**: Represents a continue statement. (Matches C++ `ContinueStatement`)

-   **`MatchStmtNode : StmtNode`**: *(Note: This node and its helpers are planned and not yet implemented.)*
    -   `std::unique_ptr<ExprNode> expression;`
    -   `std::vector<std::unique_ptr<MatchCaseNode>> cases;`
    -   **`MatchCaseNode : Node`** (Helper):
        -   `std::unique_ptr<PatternNode> pattern;`
        -   `std::unique_ptr<ExprNode> guard;`
        -   `std::unique_ptr<BlockStmtNode> body;`

-   **`ThrowStmtNode : StmtNode`**: *(Note: This node is planned and not yet implemented.)*
    -   `std::unique_ptr<ExprNode> expression;`

-   **`TryStmtNode : StmtNode`**: *(Note: This node and its helpers are planned and not yet implemented.)*
    -   `std::unique_ptr<BlockStmtNode> tryBlock;`
    -   `std::vector<CatchClauseNode> catchClauses;`
    -   `std::unique_ptr<BlockStmtNode> finallyBlock;`
    -   **`CatchClauseNode : Node`** (Helper):
        -   `std::unique_ptr<IdentifierNode> variableName;`
        -   `std::unique_ptr<TypeNode> exceptionType;`
        -   `std::unique_ptr<BlockStmtNode> body;`

-   **`DeferStmtNode : StmtNode`**: *(Note: This node is planned and not yet implemented.)*
    -   `std::unique_ptr<ExprNode> expression;`

-   **`ScopedBlockStmtNode : StmtNode`**: *(Note: This node is planned and not yet implemented.)*
    -   `std::vector<std::unique_ptr<StmtNode>> statements;`

## 6. Declaration Nodes

Derived from `vyn::Declaration : vyn::Statement`.

-   **`vyn::GenericParamNode : vyn::Node`**: Represents a generic parameter. (Matches C++ `GenericParamNode`)
    -   `std::unique_ptr<vyn::Identifier> name;`
    -   `std::vector<std::unique_ptr<vyn::TypeAnnotation>> bounds;`
    *(Note: The C++ version is simpler. Original design's `Kind { TYPE, CONST }` and `typeAnnotation` for const generics are planned enhancements.)*
-   **`vyn::FunctionParameter`** (Struct used in `FunctionDeclaration`, matches C++):
    -   `vyn::SourceLocation loc;`
    -   `std::unique_ptr<vyn::Identifier> name;`
    -   `std::unique_ptr<vyn::TypeAnnotation> typeAnnotation;`
    *(Note: Original `ParamNode` with `isMut`, `isRef` is part of a more detailed planned design.)*
-   **`vyn::FunctionDeclaration : vyn::Declaration`**: Represents a function declaration. (Matches C++ `FunctionDeclaration`)
    -   `std::unique_ptr<vyn::Identifier> id;`
    -   `std::vector<vyn::FunctionParameter> params;`
    -   `std::unique_ptr<vyn::BlockStatement> body;`
    -   `std::unique_ptr<vyn::TypeAnnotation> returnType;` // Optional
    -   `bool isAsync;`
    *(Note: Original `FuncDeclNode` with generics, extern, throwsClause details more planned features.)*
-   **`vyn::StructDeclaration : vyn::Declaration`**: Represents a struct declaration. (Matches C++ `StructDeclaration`)
    -   `std::unique_ptr<vyn::Identifier> name;`
    -   `std::vector<std::unique_ptr<vyn::GenericParamNode>> genericParams;`
    -   `std::vector<std::unique_ptr<vyn::FieldDeclaration>> fields;`
-   **`vyn::FieldDeclaration : vyn::Declaration`**: Represents a field declaration. (Matches C++ `FieldDeclaration`)
    -   `std::unique_ptr<vyn::Identifier> name;`
    -   `std::unique_ptr<vyn::TypeAnnotation> typeAnnotation;` // Mandatory
    -   `std::unique_ptr<vyn::Expression> initializer;`     // Optional
    -   `bool isMutable;`
-   **`vyn::ClassDeclaration : vyn::Declaration`**: Represents a class declaration. (Matches C++ `ClassDeclaration`)
    -   `std::unique_ptr<vyn::Identifier> name;`
    -   `std::vector<std::unique_ptr<vyn::GenericParamNode>> genericParams;`
    -   `std::vector<std::unique_ptr<vyn::Declaration>> members;` // `FieldDeclaration` or `FunctionDeclaration`
-   **`vyn::ImplDeclaration : vyn::Declaration`**: Represents an implementation block. (Matches C++ `ImplDeclaration`)
    -   `std::vector<std::unique_ptr<vyn::GenericParamNode>> genericParams;`
    -   `std::unique_ptr<vyn::TypeAnnotation> selfType;`
    -   `std::unique_ptr<vyn::TypeAnnotation> traitType;` // Optional
    -   `std::vector<std::unique_ptr<vyn::FunctionDeclaration>> methods;`
-   **`vyn::EnumVariantNode : vyn::Declaration`**: Represents an enum variant. (Matches C++ `EnumVariantNode`)
    -   `std::unique_ptr<vyn::Identifier> name;`
    -   `std::vector<std::unique_ptr<vyn::TypeAnnotation>> types;` // For tuple-like parameters
-   **`vyn::EnumDeclaration : vyn::Declaration`**: Represents an enum declaration. (Matches C++ `EnumDeclaration`)
    -   `std::unique_ptr<vyn::Identifier> name;`
    -   `std::vector<std::unique_ptr<vyn::GenericParamNode>> genericParams;`
    -   `std::vector<std::unique_ptr<vyn::EnumVariantNode>> variants;`
-   **`vyn::TypeAliasDeclaration : vyn::Declaration`**: Represents a type alias. (Matches C++ `TypeAliasDeclaration`)
    -   `std::unique_ptr<vyn::Identifier> name;`
    -   `std::unique_ptr<vyn::TypeAnnotation> typeAnnotation;`
    *(Note: Original `TypeAliasDeclNode` with generics is a planned enhancement.)*
-   **`vyn::ImportDeclaration : vyn::Declaration`**: Represents an import declaration. (Matches C++ `ImportDeclaration`)
    -   `std::unique_ptr<vyn::StringLiteral> source;`
    -   `std::vector<vyn::ImportSpecifier> specifiers;`
    -   `std::unique_ptr<vyn::Identifier> defaultImport;` // Optional
    -   `std::unique_ptr<vyn::Identifier> namespaceImport;` // Optional
    -   **`vyn::ImportSpecifier`** (Helper struct, matches C++):
        -   `vyn::SourceLocation loc;`
        -   `std::unique_ptr<vyn::Identifier> importedName;`
        -   `std::unique_ptr<vyn::Identifier> localName;` // Optional alias
    *(Note: This reflects the ES6-style import structure in C++. The simpler `PathNode`-based import is a different design aspect.)*

-   **`GlobalVarDeclNode : DeclNode`**: *(Note: This specific node is planned. Global variables would likely use `VariableDeclaration` at the module level, but specific semantics for `const` globals might evolve.)*
    -   `std::unique_ptr<PatternNode> pattern;`
    -   `std::unique_ptr<TypeNode> typeAnnotation;`
    -   `std::unique_ptr<ExprNode> initializer;`
    -   `bool isMutable;`
    -   `bool isConst;`

-   **`SmuggleDeclNode : DeclNode`**: *(Note: This node is planned and not yet implemented.)*
    -   `std::unique_ptr<PathNode> path;`

## 7. Type Representation (`vyn::TypeAnnotation`)

In the current C++ implementation, type information is primarily handled by the `vyn::TypeAnnotation` class, rather than a hierarchy of distinct `TypeNode` classes.

-   **`vyn::TypeAnnotation : vyn::Node`**: (Matches C++ `TypeAnnotation`)
    -   Can represent:
        -   **Simple Types**: e.g., `int`, `MyClass`. Stored via `std::unique_ptr<vyn::Identifier> simpleTypeName;`
        -   **Array Types**: e.g., `int[]`. Stored via `std::unique_ptr<vyn::TypeAnnotation> arrayElementType;`
        -   **Generic Types**: e.g., `List<string>`. Stored via `std::unique_ptr<vyn::Identifier> genericBaseType;` and `std::vector<std::unique_ptr<vyn::TypeAnnotation>> genericTypeArguments;`
    -   Constructors enforce one of these states.
    -   Helper methods: `isSimpleType()`, `isArrayType()`, `isGenericType()`.

*(The following specific TypeNode definitions from the original design are planned features or conceptual categorizations not directly mapped to distinct C++ classes at this time. The `vyn::TypeAnnotation` aims to cover some of these, while others like pointer or function types would require extensions or new specific nodes in the future.)*

-   **`IdentifierTypeNode : TypeNode`**: *(Conceptual/Planned; covered by `TypeAnnotation` with `simpleTypeName` or `genericBaseType`)*
    -   `std::unique_ptr<PathNode> path;`
-   **`ArrayTypeNode : TypeNode`**: *(Conceptual/Planned; covered by `TypeAnnotation` with `arrayElementType`)*
    -   `std::unique_ptr<TypeNode> elementType;`
    -   `std::unique_ptr<ExprNode> size;` // Optional size is a planned detail.
-   **`PointerTypeNode : TypeNode`**: *(Note: This type is planned and not yet implemented.)*
    -   `std::unique_ptr<TypeNode> pointedToType;`
    -   `bool isMutable;`
-   **`OptionalTypeNode : TypeNode`**: *(Note: This type is planned and not yet implemented.)*
    -   `std::unique_ptr<TypeNode> wrappedType;`
-   **`ReferenceTypeNode : TypeNode`**: *(Note: This type is planned and not yet implemented.)*
    -   `std::unique_ptr<TypeNode> referencedType;`
    -   `bool isMutable;`
-   **`FunctionTypeNode : TypeNode`**: *(Note: This type is planned and not yet implemented.)*
    -   `std::vector<std::unique_ptr<TypeNode>> parameterTypes;`
    -   `std::unique_ptr<TypeNode> returnType;`
    -   `bool isVariadic;`
-   **`GenericInstanceTypeNode : TypeNode`**: *(Conceptual/Planned; covered by `TypeAnnotation` with `genericBaseType` and `genericTypeArguments`)*
    -   `std::unique_ptr<TypeNode> genericType;`
    -   `std::vector<std::unique_ptr<TypeNode>> typeArguments;`

## 8. Pattern Nodes
*(Note: Pattern nodes and destructuring features are planned and not yet implemented. The `toString()` in `ast.cpp` had commented-out code for `IdentifierPatternNode`, indicating early thought but no current implementation.)*

Derived from `PatternNode : Node` (conceptual base class). Pattern nodes are used in variable declarations (planned for destructuring), for-in loops (planned), and match expressions (planned).

-   **`IdentifierPatternNode : PatternNode`**: Binds a value to an identifier, e.g., `x` in `var x = ...`.
    -   `std::unique_ptr<IdentifierNode> identifier;`
    -   `bool isMutable;` // Added: true if the binding is mutable (e.g. `var mut x` or `var x` where context implies mutability)
-   **`LiteralPatternNode : PatternNode`**: Matches a specific literal value.
    -   `std::unique_ptr<ExprNode> literal;` (e.g., `IntLiteralNode`, `StringLiteralNode`)
-   **`WildcardPatternNode : PatternNode`**: `_`, matches anything without binding.
-   **`TuplePatternNode : PatternNode`**: Matches and destructures a tuple, e.g., `(a, _, c)`.
    -   `std::vector<std::unique_ptr<PatternNode>> elements;`
-   **`EnumVariantPatternNode : PatternNode`**: Matches and destructures an enum variant, e.g., `Option::Some(x)`.
    -   `std::unique_ptr<PathNode> path;` (For `Option::Some`)
    -   `std::vector<std::unique_ptr<PatternNode>> arguments;` (For `x`)
-   **`StructPatternNode : PatternNode`**: Matches and destructures a struct, e.g., `Point { x: 0, y }`.
    -   `std::unique_ptr<PathNode> struct_path;` // Name/path of the struct (e.g., "Point" or "my::Point").
    -   `std::vector<StructPatternField> fields;`
    -   `// bool has_rest_pattern; // For .. syntax`
    -   **`StructPatternField`** (Helper struct, not an AST `Node`):
        -   `SourceLocation location;`
        -   `std::string fieldName;`
        -   `std::unique_ptr<PatternNode> pattern;` // Optional: if null, shorthand for fieldName: fieldName

## 9. Module Node (`vyn::Module`)

The `vyn::Module` node is the root of the AST for a single source file. It inherits from `vyn::Node`.

-   **`vyn::Module : vyn::Node`** (Matches C++ `Module`)
    -   Implicitly has `vyn::SourceLocation loc;` (inherited from `vyn::Node`), which includes file path information.
    -   `std::vector<std::unique_ptr<vyn::Statement>> body;` (Stores a sequence of statements, including declarations. This matches `ast.hpp`'s `std::vector<StmtPtr> body;` where `StmtPtr` is `std::unique_ptr<vyn::Statement>`.)

## 10. AST Traversal and Manipulation (Visitor)

The Visitor pattern is used for operating on the AST. Each concrete AST node has an `accept(Visitor& visitor)` method.

```cpp
// Visitor interface as defined in include/vyn/ast.hpp
namespace vyn { // Corrected namespace

class Visitor {
public:
    virtual ~Visitor() = default;

    // Literals (Matches ast.hpp)
    virtual void visit(class Identifier* node) = 0;
    virtual void visit(class IntegerLiteral* node) = 0;
    virtual void visit(class FloatLiteral* node) = 0;
    virtual void visit(class StringLiteral* node) = 0;
    virtual void visit(class BooleanLiteral* node) = 0;
    virtual void visit(class ArrayLiteral* node) = 0;
    virtual void visit(class ObjectLiteral* node) = 0;

    // Expressions (Matches ast.hpp)
    virtual void visit(class UnaryExpression* node) = 0;
    virtual void visit(class BinaryExpression* node) = 0;
    virtual void visit(class CallExpression* node) = 0;
    virtual void visit(class MemberExpression* node) = 0;
    virtual void visit(class AssignmentExpression* node) = 0;

    // Statements (Matches ast.hpp)
    virtual void visit(class BlockStatement* node) = 0;
    virtual void visit(class ExpressionStatement* node) = 0;
    virtual void visit(class IfStatement* node) = 0;
    virtual void visit(class ForStatement* node) = 0;
    virtual void visit(class WhileStatement* node) = 0;
    virtual void visit(class ReturnStatement* node) = 0;
    virtual void visit(class BreakStatement* node) = 0;
    virtual void visit(class ContinueStatement* node) = 0;

    // Declarations (Matches ast.hpp)
    virtual void visit(class VariableDeclaration* node) = 0;
    virtual void visit(class FunctionDeclaration* node) = 0;
    virtual void visit(class TypeAliasDeclaration* node) = 0;
    virtual void visit(class ImportDeclaration* node) = 0;
    virtual void visit(class StructDeclaration* node) = 0;
    virtual void visit(class ClassDeclaration* node) = 0;
    virtual void visit(class FieldDeclaration* node) = 0;
    virtual void visit(class ImplDeclaration* node) = 0;
    virtual void visit(class EnumDeclaration* node) = 0;
    virtual void visit(class EnumVariantNode* node) = 0;
    virtual void visit(class GenericParamNode* node) = 0;
    
    // Other (Matches ast.hpp)
    virtual void visit(class TypeAnnotation* node) = 0;
    virtual void visit(class Module* node) = 0;

    // --- Planned Visitor Methods (Not yet in ast.hpp Visitor) ---
    // These methods correspond to AST nodes that are part of the design
    // but not yet implemented in C++ or its Visitor interface.

    // Planned Literals & Expressions:
    // virtual void visit(class PathNode* node) = 0; // Planned
    // virtual void visit(class CharLiteralNode* node) = 0; // Planned
    // virtual void visit(class NullLiteralNode* node) = 0; // Planned
    // virtual void visit(class TupleLiteralNode* node) = 0; // Planned
    // virtual void visit(class StructLiteralNode* node) = 0; // Planned (Note: ObjectLiteral is implemented for key-value pairs)
    // virtual void visit(class EnumLiteralNode* node) = 0; // Planned
    // virtual void visit(class AwaitExprNode* node) = 0; // Planned
    // virtual void visit(class IfExprNode* node) = 0; // Planned
    // virtual void visit(class ListComprehensionNode* node) = 0; // Planned
    // virtual void visit(class MacroInvocationNode* node) = 0; // Planned

    // Planned Statements:
    // virtual void visit(class MatchStmtNode* node) = 0; // Planned
    // virtual void visit(class MatchCaseNode* node) = 0; // Planned (helper for MatchStmtNode)
    // virtual void visit(class ThrowStmtNode* node) = 0; // Planned
    // virtual void visit(class TryStmtNode* node) = 0; // Planned
    // virtual void visit(class CatchClauseNode* node) = 0; // Planned (helper for TryStmtNode)
    // virtual void visit(class DeferStmtNode* node) = 0; // Planned
    // virtual void visit(class ScopedBlockStmtNode* node) = 0; // Planned

    // Planned Declarations:
    // virtual void visit(class GlobalVarDeclNode* node) = 0; // Planned (VariableDeclaration at module scope covers some aspects)
    // virtual void visit(class SmuggleDeclNode* node) = 0; // Planned
    // Note: vyn::FunctionParameter is a struct, not typically visited directly. vyn::GenericParamNode is visited.

    // Planned Types (Note: vyn::TypeAnnotation is the primary implemented type representation):
    // virtual void visit(class IdentifierTypeNode* node) = 0; // Planned (Conceptually covered by TypeAnnotation)
    // virtual void visit(class ArrayTypeNode* node) = 0; // Planned (Conceptually covered by TypeAnnotation)
    // virtual void visit(class PointerTypeNode* node) = 0; // Planned
    // virtual void visit(class OptionalTypeNode* node) = 0; // Planned
    // virtual void visit(class ReferenceTypeNode* node) = 0; // Planned
    // virtual void visit(class FunctionTypeNode* node) = 0; // Planned
    // virtual void visit(class GenericInstanceTypeNode* node) = 0; // Planned (Conceptually covered by TypeAnnotation)

    // Planned Patterns:
    // virtual void visit(class IdentifierPatternNode* node) = 0; // Planned
    // virtual void visit(class LiteralPatternNode* node) = 0; // Planned
    // virtual void visit(class WildcardPatternNode* node) = 0; // Planned
    // virtual void visit(class TuplePatternNode* node) = 0; // Planned
    // virtual void visit(class EnumVariantPatternNode* node) = 0; // Planned
    // virtual void visit(class StructPatternNode* node) = 0; // Planned
};

// Each concrete Node type implements:
// void accept(Visitor& visitor) override { visitor.visit(this); }
// (where 'this' is cast to the concrete type for dispatch)

} // namespace vyn
```

## 11. Integration with Existing Parser

The parser components (`BaseParser`, `DeclarationParser`, `ExpressionParser`, `StatementParser`, etc.) are responsible for constructing instances of these AST nodes. `std::unique_ptr` is used for ownership, with the `ModuleNode` ultimately owning all nodes for a file. `SourceLocation` is set by the parser for each node.

## 12. Future Considerations

-   **Annotations/Attributes**: Could be `AnnotationNode` attached to declarable nodes.
-   **Error Handling**: Robust strategies for partial ASTs or error nodes during parsing (still relevant beyond specific throw/try nodes).
-   **`scoped` block semantics**: Further define if `ScopedBlockStmtNode` is needed or if `BlockStmtNode` with metadata suffices.
-   **Const Generic Parameter Details**: Refine representation in `GenericParamNode` or consider a separate `ConstGenericParamNode` if `kind` is insufficient.
-   **Macro System Details**: The structure of `MacroInvocationNode` arguments (token stream vs. parsed expressions) needs definition. Also, macro definition nodes (`MacroDeclNode`).
-   **Operator Overloading Details**: How `operator+` in `FuncDeclNode::name` is specifically represented and resolved.

## 13. Open Questions & Discussion Points

-   **Error Handling during AST Construction**: How should the parser signal unrecoverable syntax errors? Current approach involves throwing exceptions, but alternatives like error nodes or partial ASTs could be considered. (Still relevant)
-   **Completeness of `ast.hpp` Snippet**: The provided `ast.hpp` in context primarily shows forward declarations and visitor methods for many nodes. This document assumes their member structures based on common practices and their `NodeType`. Full definitions in `ast.hpp` would be beneficial for precise documentation. (Still relevant)
-   **Struct Field Mutability**: `StructDeclNode` fields currently only store name and type. Mutability of struct fields is typically handled by the mutability of the struct instance itself (e.g. `let s = MyStruct(); s.field = ...` would be an error if fields are not inherently mutable or `s` is not `var`). This might need further clarification in the language design. (Still relevant)

### Proposal: Ternary Conditional Operator

**Syntax:** `condition ? expression_if_true : expression_if_false`

**Description:**
A ternary conditional operator provides a concise way to express a simple if-else conditional expression. It evaluates `condition`; if true, it evaluates and returns `expression_if_true`; otherwise, it evaluates and returns `expression_if_false`.

**Benefits:**
*   **Conciseness:** Can make simple conditional assignments or expressions more readable and compact compared to a full `if-else` statement block.
*   **Familiarity:** Many programmers are familiar with this operator from languages like C, C++, Java, JavaScript, Python, etc.


# Note:
This document reflects the AST structure as per the latest understanding of `ast.hpp` and `ast.cpp` implementations and Vyn language examples. It should be updated as the language and its AST evolve.

