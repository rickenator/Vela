\
<!-- filepath: /home/rick/Projects/Vyn/doc/AST.md -->
# Vyn AST Design Document

## 1. Introduction

This document outlines the design for the Abstract Syntax Tree (AST) for the Vyn programming language, reflecting the current implementation in `include/vyn/ast.hpp` and `src/ast.cpp`. The AST is a crucial intermediate representation of the source code, generated by the parser. It serves as the primary data structure for subsequent compilation phases, including semantic analysis, type checking, optimization, and code generation.

The AST faithfully represents the syntactic structure of the Vyn code.

## 2. Core AST Node Design

All AST nodes inherit from a base `Node` class.

```cpp
// Structure in include/vyn/ast.hpp
namespace Vyn::AST {

// Forward declarations for all AST node types and Visitor
// (Many forward declarations exist in ast.hpp such as IntLiteralNode, BinaryOpNode, etc.)

struct SourceLocation {
    std::string filePath;
    int line;
    int column;

    SourceLocation(std::string fp = \"\", int l = 0, int c = 0);
};

enum class NodeType {
    // Literals & Basic
    IDENTIFIER,
    PATH,
    INT_LITERAL,
    FLOAT_LITERAL,
    STRING_LITERAL,
    BOOL_LITERAL,
    CHAR_LITERAL,
    NULL_LITERAL,

    // Expressions
    UNARY_OP,
    BINARY_OP,
    CALL_EXPR,
    ARRAY_ACCESS,
    MEMBER_ACCESS,
    ASSIGNMENT,
    TUPLE_LITERAL,
    STRUCT_LITERAL,
    ENUM_LITERAL,
    AWAIT_EXPR,             // Added
    IF_EXPR,                // Added
    LIST_COMPREHENSION_EXPR, // Added
    MACRO_INVOCATION_EXPR,  // Added

    // Statements
    EXPRESSION_STMT,
    BLOCK_STMT,
    VAR_DECL_STMT,
    IF_STMT,
    FOR_STMT,
    WHILE_STMT,
    RETURN_STMT,
    BREAK_STMT,
    CONTINUE_STMT,
    MATCH_STMT,             // Added
    THROW_STMT,             // Added
    TRY_STMT,               // Added
    DEFER_STMT,             // Added
    SCOPED_BLOCK_STMT,      // Added
    // MACRO_INVOCATION_STMT, // Consider if distinct from EXPR

    // Declarations
    FUNC_DECL,
    PARAM,
    STRUCT_DECL,
    CLASS_DECL,
    FIELD_DECL,
    IMPL_DECL,
    GENERIC_PARAM,
    ENUM_DECL,
    ENUM_VARIANT,
    TYPE_ALIAS_DECL,
    GLOBAL_VAR_DECL,
    IMPORT_DECL,            // Added
    SMUGGLE_DECL,           // Added
    // CONST_GENERIC_PARAM_DECL, // Added via GenericParamNode kind

    // Types
    TYPE_NAME, // Conceptual type, IdentifierTypeNode is a concrete usage
    ARRAY_TYPE,
    POINTER_TYPE,
    OPTIONAL_TYPE,

    // Patterns
    IDENTIFIER_PATTERN,
    LITERAL_PATTERN,
    WILDCARD_PATTERN,
    TUPLE_PATTERN,
    ENUM_VARIANT_PATTERN,
    STRUCT_PATTERN, // Corrected: Was previously noted as missing

    // Module
    MODULE,

    // Base/Abstract types
    NODE,
    EXPR_NODE,
    STMT_NODE,
    DECL_NODE,
    TYPE_NODE,
    PATTERN_NODE,
    MATCH_CASE_NODE // Helper for MatchStmtNode
};

class Node {
public:
    NodeType type;
    SourceLocation location;
    Node* parent;

    Node(NodeType t, SourceLocation loc, Node* p = nullptr);
    virtual ~Node() = default;
    virtual void accept(Visitor& visitor) = 0; // Pure virtual
    virtual std::string toString(int indent = 0) const = 0; // Pure virtual
};

// Intermediate base classes
class ExprNode : public Node {
public:
    ExprNode(NodeType t, SourceLocation loc, Node* p = nullptr);
    // accept and toString are pure virtual, inherited from Node
};

class StmtNode : public Node {
public:
    StmtNode(NodeType t, SourceLocation loc, Node* p = nullptr);
    // accept and toString are pure virtual, inherited from Node
};

class DeclNode : public Node {
public:
    DeclNode(NodeType t, SourceLocation loc, Node* p = nullptr);
    // accept and toString are pure virtual, inherited from Node
};

class TypeNode : public Node {
public:
    TypeNode(NodeType t, SourceLocation loc, Node* p = nullptr);
    // accept and toString are pure virtual, inherited from Node
};

class PatternNode : public Node {
public:
    PatternNode(NodeType t, SourceLocation loc, Node* p = nullptr);
    // accept and toString are pure virtual, inherited from Node
};

} // namespace Vyn::AST
```

-   **`SourceLocation`**: Stores filename, line, and column for error messages and debugging.
-   **`NodeType`**: Enum to identify the specific type of the node. (See "Open Questions" regarding `STRUCT_PATTERN`).
-   **`parent`**: Optional pointer to the parent node.
-   **`accept(Visitor&)`**: Pure virtual method for implementing the Visitor design pattern.
-   **`toString()`**: Pure virtual method for debugging and pretty-printing the AST.
-   **Intermediate Base Classes**: `ExprNode`, `StmtNode`, `DeclNode`, `TypeNode`, `PatternNode` provide common bases for categories of nodes.

## 3. Path Node

A `PathNode` represents a qualified name, such as `module::submodule::Item`. It can be part of a Type, Expression, or Pattern.

-   **`PathNode : Node`**:
    -   `std::vector<std::unique_ptr<IdentifierNode>> segments;`
    -   `// bool is_absolute; // Optional: for paths like ::foo::bar`

## 4. Expression Nodes

Derived from `ExprNode : Node`.

-   **`IdentifierNode : ExprNode`**: Represents an identifier.
    -   `std::string name;`
-   **Literal Nodes**:
    -   **`IntLiteralNode : ExprNode`**: (Assumed structure based on `NodeType::INT_LITERAL` and Visitor)
        -   `long long value;`
    -   **`FloatLiteralNode : ExprNode`**: (Assumed structure based on `NodeType::FLOAT_LITERAL` and Visitor)
        -   `double value;`
    -   **`StringLiteralNode : ExprNode`**: (Assumed structure based on `NodeType::STRING_LITERAL` and Visitor)
        -   `std::string value;`
    -   **`BoolLiteralNode : ExprNode`**: (Assumed structure based on `NodeType::BOOL_LITERAL` and Visitor)
        -   `bool value;`
    -   **`CharLiteralNode : ExprNode`**: (Assumed structure based on `NodeType::CHAR_LITERAL` and Visitor)
        -   `char value;`
    -   **`NullLiteralNode : ExprNode`**: (Assumed structure based on `NodeType::NULL_LITERAL` and Visitor)
-   **`TupleLiteralNode : ExprNode`**: Represents a tuple literal, e.g., `(1, "hello")`.
    -   `std::vector<std::unique_ptr<ExprNode>> elements;`
-   **`StructLiteralNode : ExprNode`**: Represents a struct instantiation, e.g., `MyStruct { field1: value1, field2: value2 }`.
    -   `std::unique_ptr<TypeNode> type;` (e.g., `IdentifierTypeNode` for `MyStruct`)
    -   `std::vector<StructLiteralField> fields;`
    -   **`StructLiteralField`** (Helper struct, not an AST `Node`):
        -   `SourceLocation location;`
        -   `std::unique_ptr<IdentifierNode> name;`
        -   `std::unique_ptr<ExprNode> value;`
-   **`EnumLiteralNode : ExprNode`**: Represents an enum variant instantiation, e.g., `MyEnum::Variant(arg1)`.
    -   `std::unique_ptr<PathNode> path;` (e.g., for `MyEnum::Variant`)
    -   `std::vector<std::unique_ptr<ExprNode>> arguments;`
-   **Operator Nodes**:
    -   **`UnaryOpNode : ExprNode`**: (Assumed structure based on `NodeType::UNARY_OP` and Visitor)
        -   `Vyn::TokenType operatorType;` (e.g., `MINUS`, `NOT`)
        -   `std::unique_ptr<ExprNode> operand;`
    -   **`BinaryOpNode : ExprNode`**: (Assumed structure based on `NodeType::BINARY_OP` and Visitor)
        -   `Vyn::TokenType operatorType;` (e.g., `PLUS`, `EQUAL_EQUAL`)
        -   `std::unique_ptr<ExprNode> leftOperand;`
        -   `std::unique_ptr<ExprNode> rightOperand;`
-   **`CallExprNode : ExprNode`**: Represents a function or method call. (Assumed structure based on `NodeType::CALL_EXPR` and Visitor)
    -   `std::unique_ptr<ExprNode> callee;` (e.g., `IdentifierNode`, `MemberAccessNode`)
    -   `std::vector<std::unique_ptr<ExprNode>> arguments;`
-   **`ArrayAccessNode : ExprNode`**: Represents an array indexing operation, e.g., `arr[index]`. (Assumed structure based on `NodeType::ARRAY_ACCESS` and Visitor)
    -   `std::unique_ptr<ExprNode> array;` (Expression being indexed)
    -   `std::unique_ptr<ExprNode> index;` (Index expression)
-   **`MemberAccessNode : ExprNode`**: Represents accessing a member of a struct or object, e.g., `obj.member`. (Assumed structure based on `NodeType::MEMBER_ACCESS` and Visitor)
    -   `std::unique_ptr<ExprNode> object;`
    -   `std::unique_ptr<IdentifierNode> member;`
-   **`AssignmentNode : ExprNode`**: Represents an assignment operation, e.g., `variable = value`. (Assumed structure based on `NodeType::ASSIGNMENT` and Visitor)
    -   `std::unique_ptr<ExprNode> left;` (L-value expression)
    -   `std::unique_ptr<ExprNode> right;` (R-value expression)

-   **`AwaitExprNode : ExprNode`**: Represents an await operation, e.g., `await my_future;`.
    -   `std::unique_ptr<ExprNode> expression;` (The expression being awaited)

-   **`IfExprNode : ExprNode`**: Represents an if-else expression, e.g., `let x = if cond { val1 } else { val2 };`.
    -   `std::unique_ptr<ExprNode> condition;`
    -   `std::unique_ptr<BlockStmtNode> thenBlock;` // Or an ExprNode if blocks are not required
    -   `std::unique_ptr<ExprNode> elseExpression;` // Mandatory for if-expression

-   **`ListComprehensionNode : ExprNode`**: Represents a list comprehension, e.g., `[x * x for x in 0..10 if x % 2 == 0]`.
    -   `std::unique_ptr<ExprNode> outputExpression;` (e.g., `x * x`)
    -   `std::unique_ptr<PatternNode> variablePattern;` (e.g., `x`)
    -   `std::unique_ptr<ExprNode> iterableExpression;` (e.g., `0..10`)
    -   `std::unique_ptr<ExprNode> filterCondition;` // Optional (e.g., `x % 2 == 0`)

-   **`MacroInvocationNode : ExprNode`**: Represents a macro invocation, e.g., `println!("Hello")`.
    -   `std::unique_ptr<PathNode> path;` (Path to the macro, e.g., `println`)
    -   `std::vector<std::unique_ptr<ExprNode>> arguments;` // Or a more flexible token stream

## 5. Statement Nodes

Derived from `StmtNode : Node`.

-   **`ExpressionStmtNode : StmtNode`**: Wraps an expression used as a statement. (Assumed structure based on `NodeType::EXPRESSION_STMT` and Visitor)
    -   `std::unique_ptr<ExprNode> expression;`
-   **`BlockStmtNode : StmtNode`**: Represents a block of statements, e.g., `{ stmt1; stmt2; }`. (Assumed structure based on `NodeType::BLOCK_STMT` and Visitor)
    -   `std::vector<std::unique_ptr<StmtNode>> statements;`
-   **`VarDeclStmtNode : StmtNode`**: Represents a variable declaration, e.g., `var x: int = 10;` or `var (a, b) = (1, 2);`.
    -   `std::unique_ptr<PatternNode> pattern;` (The pattern being declared, e.g., `IdentifierPatternNode`, `TuplePatternNode`)
    -   `std::unique_ptr<TypeNode> typeAnnotation;` // Optional
    -   `std::unique_ptr<ExprNode> initializer;` // Optional
    -   `bool isMut;` // Reflects 'var' (true) or 'let' (false)
-   **`IfStmtNode : StmtNode`**: Represents an if-else statement. (Assumed structure based on `NodeType::IF_STMT` and Visitor)
    -   `std::unique_ptr<ExprNode> condition;`
    -   `std::unique_ptr<BlockStmtNode> thenBlock;`
    -   `std::unique_ptr<Node> elseBranch;` // Can be `BlockStmtNode` or another `IfStmtNode` (for else if)
-   **`WhileStmtNode : StmtNode`**: Represents a while loop. (Assumed structure based on `NodeType::WHILE_STMT` and Visitor)
    -   `std::unique_ptr<ExprNode> condition;`
    -   `std::unique_ptr<BlockStmtNode> body;`
-   **`ForStmtNode : StmtNode`**: Represents a for loop (e.g., for-in loop). (Assumed structure based on `NodeType::FOR_STMT` and Visitor)
    -   `std::unique_ptr<PatternNode> pattern;` (Variable or pattern to bind)
    -   `std::unique_ptr<ExprNode> iterable;`
    -   `std::unique_ptr<BlockStmtNode> body;`
-   **`ReturnStmtNode : StmtNode`**: Represents a return statement. (Assumed structure based on `NodeType::RETURN_STMT` and Visitor)
    -   `std::unique_ptr<ExprNode> value;` // Optional
-   **`BreakStmtNode : StmtNode`**: Represents a break statement. (Assumed structure based on `NodeType::BREAK_STMT` and Visitor)
-   **`ContinueStmtNode : StmtNode`**: Represents a continue statement. (Assumed structure based on `NodeType::CONTINUE_STMT` and Visitor)

-   **`MatchStmtNode : StmtNode`**: Represents a match statement, e.g., `match expr { pattern1 => body1, ... }`.
    -   `std::unique_ptr<ExprNode> expression;` (The expression being matched)
    -   `std::vector<std::unique_ptr<MatchCaseNode>> cases;`
    -   **`MatchCaseNode : Node`** (Helper, not inheriting StmtNode/ExprNode directly unless it makes sense):
        -   `std::unique_ptr<PatternNode> pattern;`
        -   `std::unique_ptr<ExprNode> guard;` // Optional "if condition"
        -   `std::unique_ptr<BlockStmtNode> body;` // Or an ExprNode if match can be an expression

-   **`ThrowStmtNode : StmtNode`**: Represents a throw statement, e.g., `throw MyError("Something went wrong");`.
    -   `std::unique_ptr<ExprNode> expression;` (The error object/value being thrown)

-   **`TryStmtNode : StmtNode`**: Represents a try-catch-finally statement.
    -   `std::unique_ptr<BlockStmtNode> tryBlock;`
    -   `std::vector<CatchClauseNode> catchClauses;`
    -   `std::unique_ptr<BlockStmtNode> finallyBlock;` // Optional
    -   **`CatchClauseNode : Node`** (Helper):
        -   `std::unique_ptr<IdentifierNode> variableName;` // Optional (e.g., `e`)
        -   `std::unique_ptr<TypeNode> exceptionType;` // (e.g., `NetworkError`)
        -   `std::unique_ptr<BlockStmtNode> body;`

-   **`DeferStmtNode : StmtNode`**: Represents a defer statement, e.g., `defer file.close();`.
    -   `std::unique_ptr<ExprNode> expression;` (The expression to be deferred, typically a call)

-   **`ScopedBlockStmtNode : StmtNode`**: Represents a special `scoped` block, if its semantics differ from a standard `BlockStmtNode`.
    -   `std::vector<std::unique_ptr<StmtNode>> statements;`
    -   `// Potentially additional metadata about the scope's purpose or behavior.`

## 6. Declaration Nodes

Derived from `DeclNode : Node`.

-   **`GenericParamNode : Node`**: Represents a generic parameter in a declaration.
    -   `enum class Kind { TYPE, CONST };`
    -   `std::unique_ptr<IdentifierNode> name;`
    -   `Kind kind;` // To distinguish between type parameters (e.g., `T`) and const parameters (e.g., `N: int`)
    -   `std::unique_ptr<TypeNode> typeAnnotation;` // Optional: For const generic parameters (e.g., `int` for `N`)
    -   `std::vector<std::unique_ptr<TypeNode>> trait_bounds;`
-   **`ParamNode : DeclNode`**: Represents a parameter in a function declaration.
    -   `std::unique_ptr<IdentifierNode> name;`
    -   `std::unique_ptr<TypeNode> type;`
    -   `bool isMut;` // True if the parameter is mutable (e.g., `mut name: Type`)
    -   `bool isRef;` // True if the parameter is a reference
-   **`FuncDeclNode : DeclNode`**: Represents a function declaration.
    -   `std::unique_ptr<IdentifierNode> name;`
    -   `std::vector<std::unique_ptr<GenericParamNode>> genericParams;`
    -   `std::vector<std::unique_ptr<ParamNode>> params;`
    -   `std::unique_ptr<TypeNode> returnType;` // Optional
    -   `std::unique_ptr<BlockStmtNode> body;` // Optional (for external/interface functions)
    -   `bool isAsync;`
    -   `bool isExtern;` // Added from previous comment
    -   `std::vector<std::unique_ptr<TypeNode>> throwsClause;` // Optional: List of types this function can throw
-   **`StructDeclNode : DeclNode`**: Represents a struct declaration.
    -   `std::unique_ptr<IdentifierNode> name;`
    -   `std::vector<std::unique_ptr<GenericParamNode>> genericParams;`
    -   `std::vector<std::unique_ptr<FieldDeclNode>> fields;`
-   **`FieldDeclNode : DeclNode`**: Represents a field declaration within a class (or potentially struct in the future).
    -   `std::unique_ptr<IdentifierNode> name;`
    -   `std::unique_ptr<TypeNode> type_annotation;` // Mandatory for fields
    -   `std::unique_ptr<ExprNode> initializer;`     // Optional
    -   `bool is_mutable;`                           // true for 'var', false for 'let'/'const'
-   **`ClassDeclNode : DeclNode`**: Represents a class declaration.
    -   `std::unique_ptr<IdentifierNode> name;`
    -   `std::vector<std::unique_ptr<GenericParamNode>> generic_params;`
    -   `std::vector<std::unique_ptr<DeclNode>> members;` // Can be `FieldDeclNode` or `FuncDeclNode`
-   **`ImplDeclNode : DeclNode`**: Represents an implementation block for a struct or class.
    -   `std::vector<std::unique_ptr<GenericParamNode>> generic_params;`
    -   `std::unique_ptr<TypeNode> self_type;` (The type being implemented)
    -   `std::unique_ptr<TypeNode> trait_type;` // Optional: if implementing a trait
    -   `std::vector<std::unique_ptr<FuncDeclNode>> methods;`
-   **`EnumVariantNode : Node`**: Represents a variant within an enum declaration (e.g., `Some(T)` in `enum Option<T> { Some(T), None }`).
    -   `std::unique_ptr<IdentifierNode> name;`
    -   `std::vector<std::unique_ptr<TypeNode>> types;` // For tuple-like parameters, e.g., `Variant(Type1, Type2)`.
-   **`EnumDeclNode : DeclNode`**: Represents an enum declaration.
    -   `std::unique_ptr<IdentifierNode> name;`
    -   `std::vector<std::unique_ptr<GenericParamNode>> generic_params;`
    -   `std::vector<std::unique_ptr<EnumVariantNode>> variants;`
-   **`TypeAliasDeclNode : DeclNode`**: Represents a type alias declaration, e.g., `type MyInt<T> = T;`.
    -   `std::unique_ptr<IdentifierNode> name;`
    -   `std::vector<std::unique_ptr<GenericParamNode>> generic_params;`
    -   `std::unique_ptr<TypeNode> aliased_type;`

-   **`GlobalVarDeclNode : DeclNode`**: Represents a global variable declaration, e.g., `let x: int = 10;`, `var y = "hello";`, `const Z = 3.14;`.
    -   `std::unique_ptr<PatternNode> pattern;` (The pattern being declared, e.g., `IdentifierPatternNode` for `x`, `y`, `Z`)
    -   `std::unique_ptr<TypeNode> typeAnnotation;` // Optional
    -   `std::unique_ptr<ExprNode> initializer;`     // Optional (but usually present for `const` and often for `let`/`var`)
    -   `bool isMutable;`                           // `true` for `var`, `false` for `let` (camelCase)
    -   `bool isConst;`                             // `true` for `const` (camelCase)

-   **`ImportDeclNode : DeclNode`**: Represents an import declaration, e.g., `import vyn::fs;` or `import module::item as alias;`.
    -   `std::unique_ptr<PathNode> path;`
    -   `std::unique_ptr<IdentifierNode> alias;` // Optional

-   **`SmuggleDeclNode : DeclNode`**: Represents a smuggle declaration, e.g., `smuggle http::client;`.
    -   `std::unique_ptr<PathNode> path;`
    -   `// Potentially other attributes related to how symbols are integrated.`

## 7. Type Nodes

Derived from `TypeNode : Node`.

-   **`IdentifierTypeNode : TypeNode`**: Represents a named type, possibly qualified, e.g., `MyType`, `collections::List`.
    -   `std::unique_ptr<PathNode> path;`
-   **`ArrayTypeNode : TypeNode`**: Represents an array type, e.g., `[int; 5]` or `[string]`.
    -   `std::unique_ptr<TypeNode> elementType;`
    -   `std::unique_ptr<ExprNode> size;` // Optional
-   **`PointerTypeNode : TypeNode`**: Represents a pointer type, e.g., `*int`, `*mut string`.
    -   `std::unique_ptr<TypeNode> pointedToType;`
    -   `bool isMutable;`
-   **`OptionalTypeNode : TypeNode`**: Represents an optional type, e.g., `?int`.
    -   `std::unique_ptr<TypeNode> wrappedType;`
-   **`ReferenceTypeNode : TypeNode`**: Represents a reference type, e.g., `&int`, `&mut string`.
    -   `std::unique_ptr<TypeNode> referencedType;`
    -   `bool isMutable;`
-   **`FunctionTypeNode : TypeNode`**: Represents a function type, e.g., `fn(int, bool) -> string`.
    -   `std::vector<std::unique_ptr<TypeNode>> parameterTypes;`
    -   `std::unique_ptr<TypeNode> returnType;`
    -   `bool isVariadic;` // True if the function is variadic (e.g. C-style varargs)
-   **`GenericInstanceTypeNode : TypeNode`**: Represents an instantiation of a generic type, e.g., `List<MyType>`.
    -   `std::unique_ptr<TypeNode> genericType;` // The base generic type (e.g., `List`)
    -   `std::vector<std::unique_ptr<TypeNode>> typeArguments;` // The type arguments (e.g., `MyType`)

## 8. Pattern Nodes

Derived from `PatternNode : Node`. Used in `VarDeclStmtNode`, `ForStmtNode`, and potentially match expressions in the future.

-   **`IdentifierPatternNode : PatternNode`**: Binds a value to an identifier, e.g., `x` in `var x = ...`.
    -   `std::unique_ptr<IdentifierNode> identifier;`
    -   `bool isMutable;` // Added: true if the binding is mutable (e.g. `var mut x` or `var x` where context implies mutability)
-   **`LiteralPatternNode : PatternNode`**: Matches a specific literal value.
    -   `std::unique_ptr<ExprNode> literal;` (e.g., `IntLiteralNode`, `StringLiteralNode`)
-   **`WildcardPatternNode : PatternNode`**: `_`, matches anything without binding.
-   **`TuplePatternNode : PatternNode`**: Matches and destructures a tuple, e.g., `(a, _, c)`.
    -   `std::vector<std::unique_ptr<PatternNode>> elements;`
-   **`EnumVariantPatternNode : PatternNode`**: Matches and destructures an enum variant, e.g., `Option::Some(x)`.
    -   `std::unique_ptr<PathNode> path;` (For `Option::Some`)
    -   `std::vector<std::unique_ptr<PatternNode>> arguments;` (For `x`)
-   **`StructPatternNode : PatternNode`**: Matches and destructures a struct, e.g., `Point { x: 0, y }`.
    -   `std::unique_ptr<PathNode> struct_path;` // Name/path of the struct (e.g., "Point" or "my::Point").
    -   `std::vector<StructPatternField> fields;`
    -   `// bool has_rest_pattern; // For .. syntax`
    -   **`StructPatternField`** (Helper struct, not an AST `Node`):
        -   `SourceLocation location;`
        -   `std::string fieldName;`
        -   `std::unique_ptr<PatternNode> pattern;` // Optional: if null, shorthand for fieldName: fieldName

## 9. Module Node

The root of the AST for a single source file.

-   **`ModuleNode : Node`**:
    -   `std::string filePath;`
    -   `std::vector<std::unique_ptr<DeclNode>> body;`
    -   `// Potentially other module-level items like imports`

## 10. AST Traversal and Manipulation (Visitor)

The Visitor pattern is used for operating on the AST. Each concrete AST node has an `accept(Visitor& visitor)` method.

```cpp
// Visitor interface in include/vyn/ast.hpp
namespace Vyn::AST {

class Visitor {
public:
    virtual ~Visitor() = default;

    // Expressions
    virtual void visit(IdentifierNode* node) = 0;
    virtual void visit(PathNode* node) = 0;
    virtual void visit(IntLiteralNode* node) = 0;
    virtual void visit(FloatLiteralNode* node) = 0;
    virtual void visit(StringLiteralNode* node) = 0;
    virtual void visit(BoolLiteralNode* node) = 0;
    virtual void visit(CharLiteralNode* node) = 0; // Assuming added from previous context
    virtual void visit(NullLiteralNode* node) = 0; // Assuming added from previous context
    virtual void visit(BinaryOpNode* node) = 0;
    virtual void visit(UnaryOpNode* node) = 0;
    virtual void visit(CallExprNode* node) = 0;
    virtual void visit(ArrayAccessNode* node) = 0;
    virtual void visit(MemberAccessNode* node) = 0;
    virtual void visit(AssignmentNode* node) = 0;
    virtual void visit(TupleLiteralNode* node) = 0;
    virtual void visit(StructLiteralNode* node) = 0;
    virtual void visit(EnumLiteralNode* node) = 0;
    virtual void visit(AwaitExprNode* node) = 0;             // Added
    virtual void visit(IfExprNode* node) = 0;                // Added
    virtual void visit(ListComprehensionNode* node) = 0; // Added
    virtual void visit(MacroInvocationNode* node) = 0;  // Added

    // Statements
    virtual void visit(BlockStmtNode* node) = 0;
    virtual void visit(ReturnStmtNode* node) = 0;
    virtual void visit(IfStmtNode* node) = 0;
    virtual void visit(ExpressionStmtNode* node) = 0;
    virtual void visit(VarDeclStmtNode* node) = 0;
    virtual void visit(WhileStmtNode* node) = 0;
    virtual void visit(ForStmtNode* node) = 0;
    virtual void visit(BreakStmtNode* node) = 0;
    virtual void visit(ContinueStmtNode* node) = 0;
    virtual void visit(MatchStmtNode* node) = 0;             // Added
    virtual void visit(MatchCaseNode* node) = 0;           // Added (helper for MatchStmtNode)
    virtual void visit(ThrowStmtNode* node) = 0;             // Added
    virtual void visit(TryStmtNode* node) = 0;               // Added
    virtual void visit(CatchClauseNode* node) = 0;         // Added (helper for TryStmtNode)
    virtual void visit(DeferStmtNode* node) = 0;             // Added
    virtual void visit(ScopedBlockStmtNode* node) = 0;      // Added

    // Declarations
    virtual void visit(ParamNode* node) = 0;
    virtual void visit(FuncDeclNode* node) = 0;
    virtual void visit(StructDeclNode* node) = 0;
    virtual void visit(FieldDeclNode* node) = 0;
    virtual void visit(ClassDeclNode* node) = 0;
    virtual void visit(ImplDeclNode* node) = 0;
    virtual void visit(GenericParamNode* node) = 0;
    virtual void visit(EnumVariantNode* node) = 0;
    virtual void visit(EnumDeclNode* node) = 0;
    virtual void visit(TypeAliasDeclNode* node) = 0;
    virtual void visit(GlobalVarDeclNode* node) = 0;
    virtual void visit(ImportDeclNode* node) = 0;            // Added
    virtual void visit(SmuggleDeclNode* node) = 0;           // Added

    // Types
    // ... (existing type visits) ...
    virtual void visit(IdentifierTypeNode* node) = 0;
    virtual void visit(ArrayTypeNode* node) = 0;
    virtual void visit(PointerTypeNode* node) = 0;
    virtual void visit(OptionalTypeNode* node) = 0;
    virtual void visit(ReferenceTypeNode* node) = 0;       // Assuming added from previous context
    virtual void visit(FunctionTypeNode* node) = 0;        // Assuming added from previous context
    virtual void visit(GenericInstanceTypeNode* node) = 0; // Assuming added from previous context


    // Patterns
    // ... (existing pattern visits) ...
    virtual void visit(IdentifierPatternNode* node) = 0;
    virtual void visit(LiteralPatternNode* node) = 0;
    virtual void visit(WildcardPatternNode* node) = 0;
    virtual void visit(TuplePatternNode* node) = 0;
    virtual void visit(EnumVariantPatternNode* node) = 0;
    virtual void visit(StructPatternNode* node) = 0;

    // Module
    virtual void visit(ModuleNode* node) = 0;
};

// Each concrete Node type implements:
// void accept(Visitor& visitor) override { visitor.visit(this); }
// (where \'this\' is cast to the concrete type for dispatch)

} // namespace Vyn::AST
```

## 11. Integration with Existing Parser

The parser components (`BaseParser`, `DeclarationParser`, `ExpressionParser`, `StatementParser`, etc.) are responsible for constructing instances of these AST nodes. `std::unique_ptr` is used for ownership, with the `ModuleNode` ultimately owning all nodes for a file. `SourceLocation` is set by the parser for each node.

## 12. Future Considerations

-   **Annotations/Attributes**: Could be `AnnotationNode` attached to declarable nodes.
-   **Error Handling**: Robust strategies for partial ASTs or error nodes during parsing (still relevant beyond specific throw/try nodes).
-   **`scoped` block semantics**: Further define if `ScopedBlockStmtNode` is needed or if `BlockStmtNode` with metadata suffices.
-   **Const Generic Parameter Details**: Refine representation in `GenericParamNode` or consider a separate `ConstGenericParamNode` if `kind` is insufficient.
-   **Macro System Details**: The structure of `MacroInvocationNode` arguments (token stream vs. parsed expressions) needs definition. Also, macro definition nodes (`MacroDeclNode`).
-   **Operator Overloading Details**: How `operator+` in `FuncDeclNode::name` is specifically represented and resolved.

## 13. Open Questions & Discussion Points

-   **Error Handling during AST Construction**: How should the parser signal unrecoverable syntax errors? Current approach involves throwing exceptions, but alternatives like error nodes or partial ASTs could be considered. (Still relevant)
-   **Completeness of `ast.hpp` Snippet**: The provided `ast.hpp` in context primarily shows forward declarations and visitor methods for many nodes. This document assumes their member structures based on common practices and their `NodeType`. Full definitions in `ast.hpp` would be beneficial for precise documentation. (Still relevant)
-   **Struct Field Mutability**: `StructDeclNode` fields currently only store name and type. Mutability of struct fields is typically handled by the mutability of the struct instance itself (e.g. `let s = MyStruct(); s.field = ...` would be an error if fields are not inherently mutable or `s` is not `var`). This might need further clarification in the language design. (Still relevant)

This document reflects the AST structure as per the latest understanding of `ast.hpp` and `ast.cpp` implementations and Vyn language examples. It should be updated as the language and its AST evolve.
