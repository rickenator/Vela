# Vyn AST Design Document

## 1. Introduction

This document outlines the design for the Abstract Syntax Tree (AST) for the Vyn programming language. The AST is a crucial intermediate representation of the source code, generated by the parser. It serves as the primary data structure for subsequent compilation phases, including semantic analysis, type checking, optimization, and ultimately, the generation of Vyn Intermediate Representation (VIR) and eventually LLVM IR or other backend targets.

The AST faithfully represents the syntactic structure of the Vyn code as defined by its grammar. For the EBNF grammar, refer to the `README.md` and `include/vyn/vyn.hpp`.

## 2. Core AST Node Design

All AST nodes will inherit from a base `Node` class or struct.

```cpp
// Tentative structure in include/vyn/ast.hpp
namespace Vyn::AST {

enum class NodeType {
    // Expressions
    IDENTIFIER,
    INT_LITERAL, FLOAT_LITERAL, STRING_LITERAL, BOOL_LITERAL, CHAR_LITERAL, RUNE_LITERAL, BYTES_LITERAL, NIL_LITERAL,
    UNARY_OP, BINARY_OP,
    CALL_EXPR, MEMBER_ACCESS,
    ARRAY_LITERAL, TUPLE_LITERAL,
    IF_EXPR, LIST_COMPREHENSION, AWAIT_EXPR,

    // Statements
    EXPRESSION_STMT, BLOCK_STMT,
    CONST_DECL_STMT, VAR_DECL_STMT,
    IF_STMT, FOR_STMT, WHILE_STMT,
    RETURN_STMT, DEFER_STMT, AWAIT_STMT,
    TRY_STMT, CATCH_CLAUSE,
    MATCH_STMT, MATCH_CASE,
    IMPORT_STMT, SMUGGLE_STMT,

    // Declarations
    FUNC_DECL, TEMPLATE_DECL, CLASS_DECL, ENUM_DECL, ENUM_VARIANT,
    PARAM,

    // Types
    TYPE_NAME, ARRAY_TYPE, REF_TYPE, TUPLE_TYPE, FUNCTION_TYPE, GENERIC_INSTANCE_TYPE,

    // Patterns
    IDENTIFIER_PATTERN, LITERAL_PATTERN, WILDCARD_PATTERN, TUPLE_PATTERN, ENUM_VARIANT_PATTERN,

    // Module
    MODULE,

    // Misc
    UNKNOWN
};

struct SourceLocation {
    std::string filePath;
    int line;
    int column;
};

class Node {
public:
    NodeType type = NodeType::UNKNOWN;
    SourceLocation location;
    Node* parent = nullptr; // Optional, might be useful
    std::vector<std::unique_ptr<Node>> children; // Generic way to hold children, or specific members in derived classes

    Node(NodeType t, SourceLocation loc) : type(t), location(loc) {}
    virtual ~Node() = default;

    // For Visitor pattern
    // virtual void accept(Visitor& visitor) = 0;
    virtual std::string toString(int indent = 0) const = 0;
};

} // namespace Vyn::AST
```

-   **`SourceLocation`**: Stores filename, line, and column for error messages and debugging.
-   **`NodeType`**: Enum to identify the specific type of the node.
-   **`parent`**: Optional pointer to the parent node.
-   **`children`**: A generic way to hold child nodes, though derived classes will often have specific named members for children.
-   **`accept(Visitor&)`**: For implementing the Visitor design pattern for AST traversals.
-   **`toString()`**: For debugging and pretty-printing the AST.

## 3. Expression Nodes

Derived from `ExprNode : Node`.

-   **`IdentifierNode`**: `std::string name;`
-   **`LiteralNode`**: Base for literals.
    -   `IntLiteralNode`: `long long value;`
    -   `FloatLiteralNode`: `double value;`
    -   `StringLiteralNode`: `std::string value;`
    -   `BoolLiteralNode`: `bool value;`
    -   `CharLiteralNode`: `char value;` (UTF-8 code unit)
    -   `RuneLiteralNode`: `char32_t value;` (Unicode code point)
    -   `BytesLiteralNode`: `std::vector<uint8_t> value;`
    -   `NilLiteralNode`: Represents `nil` or a similar concept.
-   **`UnaryOpNode`**:
    -   `TokenType operatorType;` (e.g., `BANG`, `MINUS` for negation)
    -   `std::unique_ptr<ExprNode> operand;`
-   **`BinaryOpNode`**:
    -   `TokenType operatorType;` (e.g., `PLUS`, `LESS_THAN`)
    -   `std::unique_ptr<ExprNode> leftOperand;`
    -   `std::unique_ptr<ExprNode> rightOperand;`
-   **`CallExprNode`**:
    -   `std::unique_ptr<ExprNode> callee;` (e.g., `IdentifierNode`, `MemberAccessNode`)
    -   `std::vector<std::unique_ptr<ExprNode>> arguments;`
-   **`MemberAccessNode`**: `object.member`
    -   `std::unique_ptr<ExprNode> object;`
    -   `std::unique_ptr<IdentifierNode> member;`
-   **`ArrayLiteralNode`**: `[elem1, elem2]`
    -   `std::vector<std::unique_ptr<ExprNode>> elements;`
-   **`TupleLiteralNode`**: `(elem1, elem2)` (Planned)
    -   `std::vector<std::unique_ptr<ExprNode>> elements;`
-   **`IfExprNode`**: `if cond then_expr else else_expr`
    -   `std::unique_ptr<ExprNode> condition;`
    -   `std::unique_ptr<ExprNode> thenBranch;`
    -   `std::unique_ptr<ExprNode> elseBranch;` // Optional
-   **`ListComprehensionNode`**: `[expr for var in iterable]`
    -   `std::unique_ptr<ExprNode> outputExpression;`
    -   `std::unique_ptr<IdentifierNode> variable;`
    -   `std::unique_ptr<ExprNode> iterable;`
    -   `std::unique_ptr<ExprNode> rangeEnd;` // Optional for `..` syntax
-   **`AwaitExprNode`**: `await future_expr`
    -   `std::unique_ptr<ExprNode> expression;`

## 4. Statement Nodes

Derived from `StmtNode : Node`.

-   **`ExpressionStmtNode`**: Wraps an expression that is used as a statement.
    -   `std::unique_ptr<ExprNode> expression;`
-   **`BlockStmtNode`**: `{ stmt1; stmt2; }` or indented block.
    -   `std::vector<std::unique_ptr<StmtNode>> statements;`
-   **Declaration Statements (also act as declarations, might have a common base with top-level declarations)**
    -   **`ConstDeclNode`**: `const name: Type = value;`
        -   `std::unique_ptr<IdentifierNode> name;`
        -   `std::unique_ptr<TypeNode> typeAnnotation;` // Optional
        -   `std::unique_ptr<ExprNode> initializer;`
    -   **`VarDeclNode`**: `var name: Type = value;` or `var name: Type;`
        -   `std::unique_ptr<IdentifierNode> name;`
        -   `std::unique_ptr<TypeNode> typeAnnotation;` // Optional
        -   `std::unique_ptr<ExprNode> initializer;` // Optional
-   **`IfStmtNode`**: `if cond { ... } else { ... }`
    -   `std::unique_ptr<ExprNode> condition;`
    -   `std::unique_ptr<BlockStmtNode> thenBlock;`
    -   `std::unique_ptr<Node> elseBranch;` // Can be `BlockStmtNode` or another `IfStmtNode`
-   **`ForStmtNode`**: `for var in iterable { ... }`
    -   `std::unique_ptr<IdentifierNode> variable;`
    -   `std::unique_ptr<ExprNode> iterable;`
    -   `std::unique_ptr<BlockStmtNode> body;`
-   **`WhileStmtNode`**: `while cond { ... }` (Planned)
    -   `std::unique_ptr<ExprNode> condition;`
    -   `std::unique_ptr<BlockStmtNode> body;`
-   **`ReturnStmtNode`**: `return expr;`
    -   `std::unique_ptr<ExprNode> value;` // Optional
-   **`DeferStmtNode`**: `defer expr;`
    -   `std::unique_ptr<ExprNode> expression;`
-   **`AwaitStmtNode`**: `await expr;` (If `await` can be a statement, distinct from `AwaitExprNode`)
    -   `std::unique_ptr<ExprNode> expression;`
-   **`TryStmtNode`**: `try { ... } catch (e: E) { ... } finally { ... }`
    -   `std::unique_ptr<BlockStmtNode> tryBlock;`
    -   `std::vector<std::unique_ptr<CatchClauseNode>> catchClauses;`
    -   `std::unique_ptr<BlockStmtNode> finallyBlock;` // Optional
    -   **`CatchClauseNode`**: `catch (identifier: type) block`
        -   `std::unique_ptr<IdentifierNode> variableName;`
        -   `std::unique_ptr<TypeNode> variableType;`
        -   `std::unique_ptr<BlockStmtNode> body;`
-   **`MatchStmtNode`**: `match expr { pattern => result, ... }`
    -   `std::unique_ptr<ExprNode> expression;`
    -   `std::vector<std::unique_ptr<MatchCaseNode>> cases;`
    -   **`MatchCaseNode`**: `pattern => expression_or_block`
        -   `std::unique_ptr<PatternNode> pattern;`
        -   `std::unique_ptr<Node> consequence;` // Can be `ExprNode` or `BlockStmtNode`
-   **`ImportStmtNode`**: `import module::item;`
    -   `std::vector<std::unique_ptr<IdentifierNode>> path;`
    -   `bool isSmuggle;` // Differentiates from SmuggleStmtNode or have separate node
-   **`SmuggleStmtNode`**: `smuggle module::item;`
    -   `std::vector<std::unique_ptr<IdentifierNode>> path;`

## 5. Declaration Nodes

Derived from `DeclNode : Node`. These often appear at the top level of a module or within certain blocks (like classes).

-   **`FuncDeclNode`**: `async fn name(params) -> RetType { body }`
    -   `bool isAsync;`
    -   `std::unique_ptr<IdentifierNode> name;`
    -   `std::vector<std::unique_ptr<ParamNode>> parameters;`
    -   `std::unique_ptr<TypeNode> returnType;` // Optional (void if not present, or inferred)
    -   `std::unique_ptr<BlockStmtNode> body;`
    -   **`ParamNode`**: `[&mut] name: Type`
        -   `bool isRef;`
        -   `bool isMut;`
        -   `std::unique_ptr<IdentifierNode> name;`
        -   `std::unique_ptr<TypeNode> typeAnnotation;`
-   **`TemplateDeclNode`**: `template Name<T, U> { ... }`
    -   `std::unique_ptr<IdentifierNode> name;`
    -   `std::vector<std::unique_ptr<IdentifierNode>> genericParameters;`
    -   `std::unique_ptr<BlockStmtNode> body;` // Contains declarations (classes, functions) using template params
-   **`ClassDeclNode`**: `class Name: Base1, Base2 { members }`
    -   `std::unique_ptr<IdentifierNode> name;`
    -   `std::vector<std::unique_ptr<TypeNode>> baseClasses;` // Or trait implementations
    -   `std::unique_ptr<BlockStmtNode> body;` // Contains `VarDeclNode` for fields and `FuncDeclNode` for methods
-   **`EnumDeclNode`**: `enum Name { Variant1(Type1), Variant2 }` (Planned)
    -   `std::unique_ptr<IdentifierNode> name;`
    -   `std::vector<std::unique_ptr<EnumVariantNode>> variants;`
    -   **`EnumVariantNode`**: `Name(Optional<Tuple<TypeNode>>)`
        -   `std::unique_ptr<IdentifierNode> name;`
        -   `std::vector<std::unique_ptr<TypeNode>> payloadTypes;` // Empty if no payload

## 6. Type Nodes

Derived from `TypeNode : Node`.

-   **`TypeNameNode`**: Represents a named type like `Int`, `String`, or a user-defined type.
    -   `std::unique_ptr<IdentifierNode> name;`
-   **`ArrayTypeNode`**: `[ElementType; size]` or `[ElementType]`
    -   `std::unique_ptr<TypeNode> elementType;`
    -   `std::unique_ptr<ExprNode> size;` // Optional
-   **`RefTypeNode`**: `ref<Type>` or `&Type` or `&mut Type` (syntax dependent)
    -   `bool isMutable;` // For `&mut`
    -   `std::unique_ptr<TypeNode> referencedType;`
-   **`TupleTypeNode`**: `(Type1, Type2)` (Planned)
    -   `std::vector<std::unique_ptr<TypeNode>> elementTypes;`
-   **`FunctionTypeNode`**: `fn(Type1, Type2) -> RetType` (Planned)
    -   `std::vector<std::unique_ptr<TypeNode>> parameterTypes;`
    -   `std::unique_ptr<TypeNode> returnType;`
-   **`GenericInstanceTypeNode`**: `MyTemplate<ArgType1, ArgType2>`
    -   `std::unique_ptr<TypeNameNode> genericBaseName;` // e.g., "Pair"
    -   `std::vector<std::unique_ptr<TypeNode>> typeArguments;` // e.g., [Int, String]

## 7. Pattern Nodes (for Match Statements)

Derived from `PatternNode : Node`.

-   **`IdentifierPatternNode`**: Binds the matched value to a new variable.
    -   `std::unique_ptr<IdentifierNode> name;`
    -   `bool isMutable;` // Optional: `mut var`
-   **`LiteralPatternNode`**: Matches a specific literal value.
    -   `std::unique_ptr<LiteralNode> literal;`
-   **`WildcardPatternNode`**: `_`, matches anything without binding.
-   **`TuplePatternNode`**: `(pattern1, pattern2)` (Planned)
    -   `std::vector<std::unique_ptr<PatternNode>> elements;`
-   **`EnumVariantPatternNode`**: `MyEnum::Variant(p1, p2)` (Planned)
    -   `std::unique_ptr<TypeNode> enumTypePath;` // e.g., `MyEnum::Variant` could be `IdentifierNode` or `PathNode`
    -   `std::unique_ptr<IdentifierNode> variantName;`
    -   `std::vector<std::unique_ptr<PatternNode>> payloadPatterns;` // Optional

## 8. Module Node

The root of the AST for a single source file.

-   **`ModuleNode`**:
    -   `std::string filePath;`
    -   `std::vector<std::unique_ptr<DeclNode>> declarations;` (Functions, Templates, Classes, Enums)
    -   `std::vector<std::unique_ptr<StmtNode>> statements;` (Imports, Smuggles, and potentially other top-level statements if allowed by grammar)

## 9. AST Traversal and Manipulation

The **Visitor pattern** is highly recommended for operating on the AST.

```cpp
// Tentative Visitor structure
namespace Vyn::AST {

class Visitor {
public:
    virtual ~Visitor() = default;

    // Overload for each concrete Node type
    virtual void visit(IdentifierNode& node) = 0;
    virtual void visit(IntLiteralNode& node) = 0;
    // ... and so on for all other node types

    // Generic visit method (optional, can dispatch from here)
    // virtual void visit(Node& node) { /* dispatch based on node.type */ }
};

// Each Node type would then have:
// void accept(Visitor& visitor) override { visitor.visit(*this); }

} // namespace Vyn::AST
```

Use cases for Visitors:
-   **Semantic Analyzer**: Type checking, scope resolution, name binding.
-   **IR Generator**: Translating AST to VIR.
-   **Pretty Printer**: Generating Vyn source code from AST (for debugging or auto-formatting).
-   **Linter**: Enforcing coding style and detecting potential issues.

## 10. Integration with Existing Parser

The existing parser components (`BaseParser`, `DeclarationParser`, `ExpressionParser`, `StatementParser`, etc., in `src/`) will need to be updated. Instead of their current (potentially direct or simpler intermediate) actions, they will be responsible for constructing instances of these AST nodes.

-   **Node Factories**: Helper functions or methods within parser classes to create and initialize AST nodes, including setting `SourceLocation`.
-   **Ownership**: The parser will create `std::unique_ptr<Node>` instances. These will be composed into the larger AST structure. The `ModuleNode` will ultimately own all nodes for a file.
-   **Location**: AST node definitions will primarily reside in `include/vyn/ast.hpp`. Implementation (`.cpp`) files might be needed if methods become complex.

**Initial `include/vyn/ast.hpp` stubs:**
The file should be populated with the class/struct declarations outlined above, starting with `Node`, `SourceLocation`, `NodeType`, and then progressively adding specific node types. Forward declarations will be necessary.

## 11. Future Considerations

-   **Macros**:
    -   Pre-expansion: Macros might be represented as `MacroInvocationNode`.
    -   Post-expansion: The AST generated by a macro will consist of standard AST nodes. The AST might need a way to link generated nodes back to the macro invocation for source mapping.
-   **Annotations/Attributes**: `@test`, `@log_calls`
    -   Could be a generic `AnnotationNode` attached to declarable nodes (`FuncDeclNode`, `ClassDeclNode`, etc.).
    -   `std::vector<std::unique_ptr<AnnotationNode>> annotations;` on relevant nodes.
    -   `AnnotationNode` would store the annotation's name and any arguments.
-   **Template Instantiation**:
    -   The AST for a generic template (`TemplateDeclNode`) is the blueprint.
    -   When a template is instantiated (e.g., `Pair<Int>`), the semantic analyzer might create a new, specialized AST (e.g., a specialized `ClassDeclNode` or `FuncDeclNode`) by substituting template parameters. This specialized AST is then used for further compilation. The AST could store a reference from the specialized node back to its generic template and the instantiation arguments.

## 12. Open Questions & Discussion Points

-   **Template Parameter Representation**: How are template parameters (`T` in `template<T>`) represented distinctly from concrete types (`Int`) within the AST before instantiation? Perhaps a special `GenericParamTypeNode`.
-   **Error Handling during AST Construction**: If the parser encounters an unrecoverable syntax error, how should this be signaled? Partial AST construction? Nullptr nodes?
-   **Memory Management**: `std::unique_ptr` is a good default for ownership. For very large ASTs, an arena allocator could be considered for performance, but adds complexity.
-   **Distinction between Expression and Statement `await`**: The grammar shows `await_stmt` and `await` in `unary_expr`. This implies `AwaitExprNode` and `AwaitStmtNode` (which would wrap an `AwaitExprNode`). This seems reasonable.
-   **Mutability in Patterns**: `match x { mut y => ... }`. The `IdentifierPatternNode` should capture this.
-   **Path Resolution**: For `import foo::bar::baz` or type names like `collections::List<T>`, a `PathNode` (which could be a list of `IdentifierNode`s) might be more suitable than a single `IdentifierNode` or `TypeNameNode` in some contexts. This can be refined as semantic analysis requirements become clearer.

This design document provides a comprehensive starting point for implementing the Vyn AST. It should be considered a living document, subject to revisions as implementation proceeds and new language features are developed.
