<!-- filepath: /home/rick/Projects/Vyn/doc/AST.md -->
# Vyn AST Design Document

*(Note: This document outlines the design for the Abstract Syntax Tree (AST) for the Vyn programming language. It describes both the features currently implemented in `include/vyn/ast.hpp`, `src/ast.cpp`, and `src/ast_extra.cpp`, and planned features that are not yet implemented. Sections or specific details referring to planned features will be explicitly marked.)*

## 1. Introduction

This document outlines the design for the Abstract Syntax Tree (AST) for the Vyn programming language. The AST is a crucial intermediate representation of the source code, generated by the parser. It serves as the primary data structure for subsequent compilation phases, including semantic analysis, type checking, optimization, and code generation.

The AST aims to faithfully represent the syntactic structure of the Vyn code, encompassing both current capabilities and future language extensions.

## 2. Core AST Node Design

All AST nodes inherit from a base `Node` class as defined in `include/vyn/ast.hpp`.

```cpp
// Structure in include/vyn/ast.hpp
namespace vyn { // Adjusted to \'vyn\' namespace as in ast.hpp

// Forward declarations for Visitor pattern (from ast.hpp)
class Node;
class Expression;
class Statement;
class Declaration;
class Visitor;
class StructDeclaration;
class ClassDeclaration;
class FieldDeclaration;
class ImplDeclaration;
class EnumDeclaration;
class EnumVariant;
class GenericParameter; // Formerly GenericParamNode
class TypeNode; // Was TypeAnnotation in some older doc versions

// SourceLocation is defined in "vyn/source_location.hpp"
// struct SourceLocation {
//     std::string filePath; // Conceptual representation
//     int line;
//     int column;
// };

// Base AST Node (matches ast.hpp)
class Node {\npublic:
    SourceLocation loc; // From vyn::source_location.hpp
    std::string inferredTypeName; // Added for type checking/codegen hints

    Node(SourceLocation loc);\n    virtual ~Node() = default;\n    virtual NodeType getType() const = 0;\n    virtual std::string toString() const = 0;\n    virtual void accept(Visitor& visitor) = 0;\n    // Note: \'parent\' pointer is not part of the current C++ Node class.\n};\n\n// Base Expression Node (matches ast.hpp)\nclass Expression : public Node {\npublic:\n    Expression(SourceLocation loc);\n};\n\n// Base Statement Node (matches ast.hpp)\nclass Statement : public Node {\npublic:\n    Statement(SourceLocation loc);\n};\n\n// Base Declaration Node (matches ast.hpp, Declarations are Statements)\nclass Declaration : public Statement {\npublic:\n    Declaration(SourceLocation loc);\n};\n\n// Conceptual base classes from original design\n// class TypeNode : public Node { /* ... */ }; // *(Note: This specific base class is conceptual; vyn::ast::TypeNode is the implemented type representation.)*\n// class PatternNode : public Node { /* ... */ }; // *(Note: This base class is conceptual. Pattern structures are defined in the EBNF and corresponding AST nodes are planned for implementation.)*\n\n} // namespace vyn
```

-   **`vyn::SourceLocation`**: Defined in `vyn/source_location.hpp`. Stores filename, line, and column.
-   **`vyn::NodeType`**: Enum to identify the specific type of the node, reflecting the current C++ implementation.
-   **`vyn::Node::loc`**: The source location of the node.
-   **`vyn::Node::inferredTypeName`**: A string for type checking or code generation hints.
-   **`vyn::Node::getType()`**: Returns the `NodeType` of the node.
-   **`vyn::Node::accept(Visitor&)`**: Pure virtual method for the Visitor pattern.
-   **`vyn::Node::toString()`**: Pure virtual method for debugging.
-   **Implemented Base Classes**: `vyn::Expression`, `vyn::Statement`, `vyn::Declaration` (which inherits from `Statement`).
-   **Planned Node Categories**: `PatternNode` represent categories of nodes that are part of the broader language design but are not yet implemented as specific base classes in C++ or have limited/different representation.

## 3. AST Node Types (`NodeType` Enum)

The `NodeType` enum, defined in `vyn/parser/ast.hpp`, provides a unique identifier for each type of AST node. This is crucial for type-safe downcasting and for visitors to determine the concrete type of a `Node*`.

```cpp
enum class NodeType {
    // Literals
    IDENTIFIER,
    INTEGER_LITERAL,
    FLOAT_LITERAL,
    STRING_LITERAL,
    BOOLEAN_LITERAL,
    ARRAY_LITERAL,         // Formerly ARRAY_LITERAL_NODE
    OBJECT_LITERAL,        // Formerly OBJECT_LITERAL_NODE
    NIL_LITERAL,

    // Expressions
    UNARY_EXPRESSION,
    BINARY_EXPRESSION,
    CALL_EXPRESSION,
    CONSTRUCTION_EXPRESSION, // New: For TypeName(arguments)
    ARRAY_INITIALIZATION_EXPRESSION, // New: For [Type; Size]()
    MEMBER_EXPRESSION,
    ASSIGNMENT_EXPRESSION,
    IF_EXPRESSION,      // New: For if-expressions - Check C++ impl status
    RANGE_EXPRESSION,   // New: For range expressions (e.g., a..b) - Check C++ impl status
    BORROW_EXPRESSION,     // Formerly BORROW_EXPRESSION_NODE
    POINTER_DEREF_EXPRESSION, // Implemented
    ADDR_OF_EXPRESSION,       // Implemented
    FROM_INT_TO_LOC_EXPRESSION, // Implemented
    ARRAY_ELEMENT_EXPRESSION, // Implemented
    LOCATION_EXPRESSION,    // Implemented (from ast_extra.cpp)
    LIST_COMPREHENSION,     // Implemented (from ast_extra.cpp)


    // Statements
    BLOCK_STATEMENT,
    EXPRESSION_STATEMENT,
    IF_STATEMENT,
    FOR_STATEMENT,
    WHILE_STATEMENT,
    RETURN_STATEMENT,
    BREAK_STATEMENT,
    CONTINUE_STATEMENT,
    THROW_STATEMENT,    // New: For throw statements - Check C++ impl status
    SCOPED_STATEMENT,   // New: For scoped blocks - Check C++ impl status
    PATTERN_ASSIGNMENT_STATEMENT, // New: For pattern-based assignments - Check C++ impl status
    TRY_STATEMENT,      // Implemented

    // Declarations
    VARIABLE_DECLARATION,
    FUNCTION_DECLARATION,
    TYPE_ALIAS_DECLARATION,
    IMPORT_DECLARATION,
    STRUCT_DECLARATION,
    CLASS_DECLARATION,  // Note: May be superseded or refined by traits/impls
    FIELD_DECLARATION,
    IMPL_DECLARATION,
    ENUM_DECLARATION,
    ENUM_VARIANT,
    GENERIC_PARAMETER,    // Formerly GENERIC_PARAM_NODE
    TRAIT_DECLARATION,  // New: For trait definitions - Check C++ impl status
    METHOD_SIGNATURE,   // New: For method signatures within traits - Check C++ impl status
    TEMPLATE_DECLARATION, // Formerly TEMPLATE_DECLARATION_NODE

    // Other
    TYPE_NODE,         // Represents type information (C++: TypeNode)
    MODULE
};
```

-   **`vyn::SourceLocation`**: Defined in `vyn/source_location.hpp`. Stores filename, line, and column.
-   **`vyn::NodeType`**: Enum to identify the specific type of the node, reflecting the current C++ implementation.
-   **`vyn::Node::loc`**: The source location of the node.
-   **`vyn::Node::inferredTypeName`**: A string for type checking or code generation hints.
-   **`vyn::Node::getType()`**: Returns the `NodeType` of the node.
-   **`vyn::Node::accept(Visitor&)`**: Pure virtual method for the Visitor pattern.
-   **`vyn::Node::toString()`**: Pure virtual method for debugging.
-   **Implemented Base Classes**: `vyn::Expression`, `vyn::Statement`, `vyn::Declaration` (which inherits from `Statement`).
-   **Planned Node Categories**: `PatternNode` represent categories of nodes that are part of the broader language design but are not yet implemented as specific base classes in C++ or have limited/different representation.

## 3. AST Node Types (`NodeType` Enum)

The `NodeType` enum, defined in `vyn/parser/ast.hpp`, provides a unique identifier for each type of AST node. This is crucial for type-safe downcasting and for visitors to determine the concrete type of a `Node*`.

```cpp
enum class NodeType {
    // Literals
    IDENTIFIER,
    INTEGER_LITERAL,
    FLOAT_LITERAL,
    STRING_LITERAL,
    BOOLEAN_LITERAL,
    ARRAY_LITERAL,         // Formerly ARRAY_LITERAL_NODE
    OBJECT_LITERAL,        // Formerly OBJECT_LITERAL_NODE
    NIL_LITERAL,

    // Expressions
    UNARY_EXPRESSION,
    BINARY_EXPRESSION,
    CALL_EXPRESSION,
    CONSTRUCTION_EXPRESSION, // New: For TypeName(arguments)
    ARRAY_INITIALIZATION_EXPRESSION, // New: For [Type; Size]()
    MEMBER_EXPRESSION,
    ASSIGNMENT_EXPRESSION,
    IF_EXPRESSION,      // New: For if-expressions - Check C++ impl status
    RANGE_EXPRESSION,   // New: For range expressions (e.g., a..b) - Check C++ impl status
    BORROW_EXPRESSION,     // Formerly BORROW_EXPRESSION_NODE
    POINTER_DEREF_EXPRESSION, // Implemented
    ADDR_OF_EXPRESSION,       // Implemented
    FROM_INT_TO_LOC_EXPRESSION, // Implemented
    ARRAY_ELEMENT_EXPRESSION, // Implemented
    LOCATION_EXPRESSION,    // Implemented (from ast_extra.cpp)
    LIST_COMPREHENSION,     // Implemented (from ast_extra.cpp)


    // Statements
    BLOCK_STATEMENT,
    EXPRESSION_STATEMENT,
    IF_STATEMENT,
    FOR_STATEMENT,
    WHILE_STATEMENT,
    RETURN_STATEMENT,
    BREAK_STATEMENT,
    CONTINUE_STATEMENT,
    THROW_STATEMENT,    // New: For throw statements - Check C++ impl status
    SCOPED_STATEMENT,   // New: For scoped blocks - Check C++ impl status
    PATTERN_ASSIGNMENT_STATEMENT, // New: For pattern-based assignments - Check C++ impl status
    TRY_STATEMENT,      // Implemented

    // Declarations
    VARIABLE_DECLARATION,
    FUNCTION_DECLARATION,
    TYPE_ALIAS_DECLARATION,
    IMPORT_DECLARATION,
    STRUCT_DECLARATION,
    CLASS_DECLARATION,  // Note: May be superseded or refined by traits/impls
    FIELD_DECLARATION,
    IMPL_DECLARATION,
    ENUM_DECLARATION,
    ENUM_VARIANT,
    GENERIC_PARAMETER,    // Formerly GENERIC_PARAM_NODE
    TRAIT_DECLARATION,  // New: For trait definitions - Check C++ impl status
    METHOD_SIGNATURE,   // New: For method signatures within traits - Check C++ impl status
    TEMPLATE_DECLARATION, // Formerly TEMPLATE_DECLARATION_NODE

    // Other
    TYPE_NODE,         // Represents type information (C++: TypeNode)
    MODULE
};
```

-   **`vyn::SourceLocation`**: Defined in `vyn/source_location.hpp`. Stores filename, line, and column.
-   **`vyn::NodeType`**: Enum to identify the specific type of the node, reflecting the current C++ implementation.
-   **`vyn::Node::loc`**: The source location of the node.
-   **`vyn::Node::inferredTypeName`**: A string for type checking or code generation hints.
-   **`vyn::Node::getType()`**: Returns the `NodeType` of the node.
-   **`vyn::Node::accept(Visitor&)`**: Pure virtual method for the Visitor pattern.
-   **`vyn::Node::toString()`**: Pure virtual method for debugging.
-   **Implemented Base Classes**: `vyn::Expression`, `vyn::Statement`, `vyn::Declaration` (which inherits from `Statement`).
-   **Planned Node Categories**: `PatternNode` represent categories of nodes that are part of the broader language design but are not yet implemented as specific base classes in C++ or have limited/different representation.

## 3. AST Node Types (`NodeType` Enum)

The `NodeType` enum, defined in `vyn/parser/ast.hpp`, provides a unique identifier for each type of AST node. This is crucial for type-safe downcasting and for visitors to determine the concrete type of a `Node*`.

```cpp
enum class NodeType {
    // Literals
    IDENTIFIER,
    INTEGER_LITERAL,
    FLOAT_LITERAL,
    STRING_LITERAL,
    BOOLEAN_LITERAL,
    ARRAY_LITERAL,         // Formerly ARRAY_LITERAL_NODE
    OBJECT_LITERAL,        // Formerly OBJECT_LITERAL_NODE
    NIL_LITERAL,

    // Expressions
    UNARY_EXPRESSION,
    BINARY_EXPRESSION,
    CALL_EXPRESSION,
    CONSTRUCTION_EXPRESSION, // New: For TypeName(arguments)
    ARRAY_INITIALIZATION_EXPRESSION, // New: For [Type; Size]()
    MEMBER_EXPRESSION,
    ASSIGNMENT_EXPRESSION,
    IF_EXPRESSION,      // New: For if-expressions - Check C++ impl status
    RANGE_EXPRESSION,   // New: For range expressions (e.g., a..b) - Check C++ impl status
    BORROW_EXPRESSION,     // Formerly BORROW_EXPRESSION_NODE
    POINTER_DEREF_EXPRESSION, // Implemented
    ADDR_OF_EXPRESSION,       // Implemented
    FROM_INT_TO_LOC_EXPRESSION, // Implemented
    ARRAY_ELEMENT_EXPRESSION, // Implemented
    LOCATION_EXPRESSION,    // Implemented (from ast_extra.cpp)
    LIST_COMPREHENSION,     // Implemented (from ast_extra.cpp)


    // Statements
    BLOCK_STATEMENT,
    EXPRESSION_STATEMENT,
    IF_STATEMENT,
    FOR_STATEMENT,
    WHILE_STATEMENT,
    RETURN_STATEMENT,
    BREAK_STATEMENT,
    CONTINUE_STATEMENT,
    THROW_STATEMENT,    // New: For throw statements - Check C++ impl status
    SCOPED_STATEMENT,   // New: For scoped blocks - Check C++ impl status
    PATTERN_ASSIGNMENT_STATEMENT, // New: For pattern-based assignments - Check C++ impl status
    TRY_STATEMENT,      // Implemented

    // Declarations
    VARIABLE_DECLARATION,
    FUNCTION_DECLARATION,
    TYPE_ALIAS_DECLARATION,
    IMPORT_DECLARATION,
    STRUCT_DECLARATION,
    CLASS_DECLARATION,  // Note: May be superseded or refined by traits/impls
    FIELD_DECLARATION,
    IMPL_DECLARATION,
    ENUM_DECLARATION,
    ENUM_VARIANT,
    GENERIC_PARAMETER,    // Formerly GENERIC_PARAM_NODE
    TRAIT_DECLARATION,  // New: For trait definitions - Check C++ impl status
    METHOD_SIGNATURE,   // New: For method signatures within traits - Check C++ impl status
    TEMPLATE_DECLARATION, // Formerly TEMPLATE_DECLARATION_NODE

    // Other
    TYPE_NODE,         // Represents type information (C++: TypeNode)
    MODULE
};
```

-   **`vyn::SourceLocation`**: Defined in `vyn/source_location.hpp`. Stores filename, line, and column.
-   **`vyn::NodeType`**: Enum to identify the specific type of the node, reflecting the current C++ implementation.
-   **`vyn::Node::loc`**: The source location of the node.
-   **`vyn::Node::inferredTypeName`**: A string for type checking or code generation hints.
-   **`vyn::Node::getType()`**: Returns the `NodeType` of the node.
-   **`vyn::Node::accept(Visitor&)`**: Pure virtual method for the Visitor pattern.
-   **`vyn::Node::toString()`**: Pure virtual method for debugging.
-   **Implemented Base Classes**: `vyn::Expression`, `vyn::Statement`, `vyn::Declaration` (which inherits from `Statement`).
-   **Planned Node Categories**: `PatternNode` represent categories of nodes that are part of the broader language design but are not yet implemented as specific base classes in C++ or have limited/different representation.

## 4. Detailed Node Descriptions

### 4.1. `Identifier`

Represents an identifier in the source code.

-   **C++ Class**: `vyn::ast::Identifier`
-   **`NodeType`**: `IDENTIFIER`
-   **Fields**:
    -   `name` (`std::string`): The name of the identifier.

```cpp
// From ast.hpp
class Identifier : public Node {
public:
    std::string name;

    Identifier(SourceLocation loc, std::string name);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.2. `IntegerLiteral`

Represents an integer literal.

-   **C++ Class**: `vyn::ast::IntegerLiteral`
-   **`NodeType`**: `INTEGER_LITERAL`
-   **Fields**:
    -   `value` (`int64_t`): The value of the literal.

```cpp
// From ast.hpp
class IntegerLiteral : public Node {
public:
    int64_t value;

    IntegerLiteral(SourceLocation loc, int64_t value);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.3. `FloatLiteral`

Represents a floating-point literal.

-   **C++ Class**: `vyn::ast::FloatLiteral`
-   **`NodeType`**: `FLOAT_LITERAL`
-   **Fields**:
    -   `value` (`double`): The value of the literal.

```cpp
// From ast.hpp
class FloatLiteral : public Node {
public:
    double value;

    FloatLiteral(SourceLocation loc, double value);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.4. `StringLiteral`

Represents a string literal.

-   **C++ Class**: `vyn::ast::StringLiteral`
-   **`NodeType`**: `STRING_LITERAL`
-   **Fields**:
    -   `value` (`std::string`): The value of the literal.

```cpp
// From ast.hpp
class StringLiteral : public Node {
public:
    std::string value;

    StringLiteral(SourceLocation loc, std::string value);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.5. `BooleanLiteral`

Represents a boolean literal.

-   **C++ Class**: `vyn::ast::BooleanLiteral`
-   **`NodeType`**: `BOOLEAN_LITERAL`
-   **Fields**:
    -   `value` (`bool`): The value of the literal.

```cpp
// From ast.hpp
class BooleanLiteral : public Node {
public:
    bool value;

    BooleanLiteral(SourceLocation loc, bool value);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.6. `NilLiteral`

Represents a `nil` literal, indicating the absence of a value.

-   **C++ Class**: `vyn::ast::NilLiteral`
-   **`NodeType`**: `NIL_LITERAL`

```cpp
// From ast.hpp
class NilLiteral : public Node {
public:
    NilLiteral(SourceLocation loc);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.7. `UnaryExpression`

Represents a unary expression, such as negation.

-   **C++ Class**: `vyn::ast::UnaryExpression`
-   **`NodeType`**: `UNARY_EXPRESSION`
-   **Fields**:
    -   `operator` (`std::string`): The unary operator (e.g., `-`, `!`).
    -   `operand` (`PExpression`): The operand of the unary expression.

```cpp
// From ast.hpp
class UnaryExpression : public Expression {
public:
    std::string operator;
    PExpression operand;

    UnaryExpression(SourceLocation loc, std::string op, PExpression operand);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.8. `BinaryExpression`

Represents a binary expression, such as addition or equality.

-   **C++ Class**: `vyn::ast::BinaryExpression`
-   **`NodeType`**: `BINARY_EXPRESSION`
-   **Fields**:
    -   `operator` (`std::string`): The binary operator (e.g., `+`, `==`).
    -   `left` (`PExpression`): The left operand.
    -   `right` (`PExpression`): The right operand.

```cpp
// From ast.hpp
class BinaryExpression : public Expression {
public:
    std::string operator;
    PExpression left;
    PExpression right;

    BinaryExpression(SourceLocation loc, std::string op, PExpression left, PExpression right);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.9. `TernaryExpression`

Represents a ternary expression (conditional expression).

-   **C++ Class**: `vyn::ast::TernaryExpression`
-   **`NodeType`**: `TERNARY_EXPRESSION`
-   **Fields**:
    -   `condition` (`PExpression`): The condition expression.
    -   `trueBranch` (`PExpression`): The expression if the condition is true.
    -   `falseBranch` (`PExpression`): The expression if the condition is false.

```cpp
// From ast.hpp
class TernaryExpression : public Expression {
public:
    PExpression condition;
    PExpression trueBranch;
    PExpression falseBranch;

    TernaryExpression(SourceLocation loc, PExpression condition, PExpression trueBranch, PExpression falseBranch);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.10. `CallExpression`

Represents a function or method call.

-   **C++ Class**: `vyn::ast::CallExpression`
-   **`NodeType`**: `CALL_EXPRESSION`
-   **Fields**:
    -   `function` (`PExpression`): The function being called.
    -   `arguments` (`std::vector<PExpression>`): The arguments passed to the function.

```cpp
// From ast.hpp
class CallExpression : public Expression {
public:
    PExpression function;
    std::vector<PExpression> arguments;

    CallExpression(SourceLocation loc, PExpression function, std::vector<PExpression> arguments);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.11. `ConstructionExpression`

Represents an expression that constructs an instance of a type (e.g., `Point(10, 20)`).

-   **C++ Class**: `vyn::ast::ConstructionExpression`
-   **`NodeType`**: `CONSTRUCTION_EXPRESSION`
-   **Fields**:
    -   `typeName` (`PExpression`): The name of the type being constructed.
    -   `arguments` (`std::vector<PExpression>`): The arguments passed to the constructor.

```cpp
// From ast.hpp
class ConstructionExpression : public Expression {
public:
    PExpression typeName;
    std::vector<PExpression> arguments;

    ConstructionExpression(SourceLocation loc, PExpression typeName, std::vector<PExpression> arguments);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.12. `ArrayInitializationExpression`

Represents the initialization of an array with a specific type and size (e.g., `[int; 10]`).

-   **C++ Class**: `vyn::ast::ArrayInitializationExpression`
-   **`NodeType`**: `ARRAY_INITIALIZATION_EXPRESSION`
-   **Fields**:
    -   `typeNode` (`PTypeNode`): The type of the array elements.
    -   `size` (`PExpression`): The size of the array.

```cpp
// From ast.hpp
class ArrayInitializationExpression : public Expression {
public:
    PTypeNode typeNode;
    PExpression size;

    ArrayInitializationExpression(SourceLocation loc, PTypeNode typeNode, PExpression size);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.13. `MemberExpression`

Represents accessing a member of a struct or class (e.g., `obj.member`).

-   **C++ Class**: `vyn::ast::MemberExpression`
-   **`NodeType`**: `MEMBER_EXPRESSION`
-   **Fields**:
    -   `object` (`PExpression`): The object being accessed.
    -   `member` (`std::string`): The name of the member.

```cpp
// From ast.hpp
class MemberExpression : public Expression {
public:
    PExpression object;
    std::string member;

    MemberExpression(SourceLocation loc, PExpression object, std::string member);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.14. `AssignmentExpression`

Represents an assignment operation (e.g., `a = b`).

-   **C++ Class**: `vyn::ast::AssignmentExpression`
-   **`NodeType`**: `ASSIGNMENT_EXPRESSION`
-   **Fields**:
    -   `left` (`PExpression`): The left-hand side expression (e.g., the variable).
    -   `right` (`PExpression`): The right-hand side expression (e.g., the value).

```cpp
// From ast.hpp
class AssignmentExpression : public Expression {
public:
    PExpression left;
    PExpression right;

    AssignmentExpression(SourceLocation loc, PExpression left, PExpression right);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.15. `IfExpression`

Represents an if-expression, which evaluates to one of two values based on a condition (e.g., `if (cond) expr1 else expr2`).

-   **C++ Class**: `vyn::ast::IfExpression`
-   **`NodeType`**: `IF_EXPRESSION`
-   **Fields**:
    -   `condition` (`PExpression`): The condition to evaluate.
    -   `trueBranch` (`PExpression`): The expression to evaluate if the condition is true.
    -   `falseBranch` (`PExpression`): The expression to evaluate if the condition is false.

```cpp
// From ast.hpp
class IfExpression : public Expression {
public:
    PExpression condition;
    PExpression trueBranch;
    PExpression falseBranch;

    IfExpression(SourceLocation loc, PExpression condition, PExpression trueBranch, PExpression falseBranch);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.16. `RangeExpression`

Represents a range expression, typically used in for-loops or to specify ranges (e.g., `1..10`).

-   **C++ Class**: `vyn::ast::RangeExpression`
-   **`NodeType`**: `RANGE_EXPRESSION`
-   **Fields**:
    -   `start` (`PExpression`): The starting value of the range.
    -   `end` (`PExpression`): The ending value of the range.

```cpp
// From ast.hpp
class RangeExpression : public Expression {
public:
    PExpression start;
    PExpression end;

    RangeExpression(SourceLocation loc, PExpression start, PExpression end);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.17. `BorrowExpression` (Formerly `BorrowExprNode`)

Represents a borrow expression (e.g., `&x`, `&mut y`).

-   **C++ Class**: `vyn::ast::BorrowExpression`
-   **`NodeType`**: `BORROW_EXPRESSION`
-   **Fields**:
    -   `expression` (`PExpression`: The expression being borrowed.
    -   `isMutable` (`bool`): True if it's a mutable borrow (`&mut`), false otherwise (`&`).

```cpp
// From ast.hpp
class BorrowExpression : public Expression { // Renamed from BorrowExprNode
public:
    PExpression expression;
    bool isMutable;

    BorrowExpression(SourceLocation loc, PExpression expression, bool isMutable);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
}; // Added missing semicolon
```

### 4.18. `PointerDerefExpression`

Represents dereferencing a pointer to access the value it points to (e.g., `*ptr`).

-   **C++ Class**: `vyn::ast::PointerDerefExpression`
-   **`NodeType`**: `POINTER_DEREF_EXPRESSION`
-   **Fields**:
    -   `pointer` (`PExpression`): The pointer expression being dereferenced.

```cpp
// From ast.hpp
class PointerDerefExpression : public Expression {
public:
    PExpression pointer;

    PointerDerefExpression(SourceLocation loc, PExpression pointer);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.19. `AddrOfExpression`

Represents the address-of operation, which gets the memory address of a variable (e.g., `&var`).

-   **C++ Class**: `vyn::ast::AddrOfExpression`
-   **`NodeType`**: `ADDR_OF_EXPRESSION`
-   **Fields**:
    -   `operand` (`PExpression`): The operand whose address is being taken.

```cpp
// From ast.hpp
class AddrOfExpression : public Expression {
public:
    PExpression operand;

    AddrOfExpression(SourceLocation loc, PExpression operand);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.20. `FromIntToLocExpression`

Represents a conversion from an integer to a location (line and column) in the source code.

-   **C++ Class**: `vyn::ast::FromIntToLocExpression`
-   **`NodeType`**: `FROM_INT_TO_LOC_EXPRESSION`
-   **Fields**:
    -   `line` (`PExpression`): The line number.
    -   `column` (`PExpression`): The column number.

```cpp
// From ast.hpp
class FromIntToLocExpression : public Expression {
public:
    PExpression line;
    PExpression column;

    FromIntToLocExpression(SourceLocation loc, PExpression line, PExpression column);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.21. `ArrayElementExpression`

Represents accessing an element of an array (e.g., `arr[0]`).

-   **C++ Class**: `vyn::ast::ArrayElementExpression`
-   **`NodeType`**: `ARRAY_ELEMENT_EXPRESSION`
-   **Fields**:
    -   `array` (`PExpression`): The array expression.
    -   `index` (`PExpression`): The index of the element.

```cpp
// From ast.hpp
class ArrayElementExpression : public Expression {
public:
    PExpression array;
    PExpression index;

    ArrayElementExpression(SourceLocation loc, PExpression array, PExpression index);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.22. `LocationExpression`

Represents an expression that yields the current location (line and column) in the source code.

-   **C++ Class**: `vyn::ast::LocationExpression`
-   **`NodeType`**: `LOCATION_EXPRESSION`

```cpp
// From ast.hpp
class LocationExpression : public Expression {
public:
    LocationExpression(SourceLocation loc);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.23. `ListComprehension`

Represents a list comprehension, which is syntactic sugar for creating lists (e.g., `[x * 2 for x in xs]`).

-   **C++ Class**: `vyn::ast::ListComprehension`
-   **`NodeType`**: `LIST_COMPREHENSION`
-   **Fields**:
    -   `element` (`PExpression`): The expression for the list element.
    -   `source` (`PExpression`): The source collection.
    -   `filter` (`PExpression`, optional): An optional filter expression.

```cpp
// From ast.hpp
class ListComprehension : public Expression {
public:
    PExpression element;
    PExpression source;
    PExpression filter; // Optional

    ListComprehension(SourceLocation loc, PExpression element, PExpression source, PExpression filter);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.24. `BlockStatement`

Represents a block of statements, typically enclosed in braces `{}`.

-   **C++ Class**: `vyn::ast::BlockStatement`
-   **`NodeType`**: `BLOCK_STATEMENT`
-   **Fields**:
    -   `statements` (`std::vector<PStatement>`): The statements in the block.

```cpp
// From ast.hpp
class BlockStatement : public Statement {
public:
    std::vector<PStatement> statements;

    BlockStatement(SourceLocation loc, std::vector<PStatement> statements);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.25. `ExpressionStatement`

Represents a statement that consists of an expression.

-   **C++ Class**: `vyn::ast::ExpressionStatement`
-   **`NodeType`**: `EXPRESSION_STATEMENT`
-   **Fields**:
    -   `expression` (`PExpression`): The expression.

```cpp
// From ast.hpp
class ExpressionStatement : public Statement {
public:
    PExpression expression;

    ExpressionStatement(SourceLocation loc, PExpression expression);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.26. `IfStatement`

Represents an if statement.

-   **C++ Class**: `vyn::ast::IfStatement`
-   **`NodeType`**: `IF_STATEMENT`
-   **Fields**:
    -   `condition` (`PExpression`): The condition to evaluate.
    -   `thenBranch` (`PStatement`): The statement to execute if the condition is true.
    -   `elseBranch` (`PStatement`, optional): The statement to execute if the condition is false.

```cpp
// From ast.hpp
class IfStatement : public Statement {
public:
    PExpression condition;
    PStatement thenBranch;
    PStatement elseBranch; // Optional

    IfStatement(SourceLocation loc, PExpression condition, PStatement thenBranch, PStatement elseBranch);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.27. `ForStatement`

Represents a for loop.

-   **C++ Class**: `vyn::ast::ForStatement`
-   **`NodeType`**: `FOR_STATEMENT`
-   **Fields**:
    -   `iterator` (`PIdentifier`): The loop variable.
    -   `range` (`PExpression`): The range or collection to iterate over.
    -   `body` (`PStatement`): The body of the loop.

```cpp
// From ast.hpp
class ForStatement : public Statement {
public:
    PIdentifier iterator;
    PExpression range;
    PStatement body;

    ForStatement(SourceLocation loc, PIdentifier iterator, PExpression range, PStatement body);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.28. `WhileStatement`

Represents a while loop.

-   **C++ Class**: `vyn::ast::WhileStatement`
-   **`NodeType`**: `WHILE_STATEMENT`
-   **Fields**:
    -   `condition` (`PExpression`): The condition to evaluate.
    -   `body` (`PStatement`): The body of the loop.

```cpp
// From ast.hpp
class WhileStatement : public Statement {
public:
    PExpression condition;
    PStatement body;

    WhileStatement(SourceLocation loc, PExpression condition, PStatement body);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.29. `ReturnStatement`

Represents a return statement.

-   **C++ Class**: `vyn::ast::ReturnStatement`
-   **`NodeType`**: `RETURN_STATEMENT`
-   **Fields**:
    -   `value` (`PExpression`, optional): The value to return.

```cpp
// From ast.hpp
class ReturnStatement : public Statement {
public:
    PExpression value; // Optional

    ReturnStatement(SourceLocation loc, PExpression value);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.30. `GenericParameter` (Formerly `GenericParamNode`)

Represents a generic parameter in a template or generic function/type definition (e.g., `T` in `fn foo<T>(p: T)`).

-   **C++ Class**: `vyn::ast::GenericParameter`
-   **`NodeType`**: `GENERIC_PARAMETER`
-   **Fields**:
    -   `name` (`PIdentifier`): The identifier of the generic parameter.
    -   `constraints` (`std::vector<PTypeNode>`): Optional type constraints for the parameter.

```cpp
// From ast.hpp
class GenericParameter : public Node { // Renamed from GenericParamNode
public:
    PIdentifier name;
    std::vector<PTypeNode> constraints;

    GenericParameter(SourceLocation loc, PIdentifier name, std::vector<PTypeNode> constraints);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.31. `TemplateDeclaration` (Formerly `TemplateDeclarationNode`)

Represents a template declaration, which can be used to define generic functions, structs, or classes.

-   **C++ Class**: `vyn::ast::TemplateDeclaration`
-   **`NodeType`**: `TEMPLATE_DECLARATION`
-   **Fields**:
    -   `name` (`PIdentifier`): The name of the template.
    -   `parameters` (`std::vector<PGenericParameter>`): A list of generic parameters for the template. (Note: `PGenericParameter` used here, reflecting the rename from `GenericParamNode`)
    -   `declaration` (`PDeclaration`): The declaration being templated (e.g., a function or struct declaration).

```cpp
// From ast.hpp
class TemplateDeclaration : public Declaration { // Renamed from TemplateDeclarationNode
public:
    PIdentifier name;
    std::vector<PGenericParameter> parameters; // Updated to PGenericParameter
    PDeclaration declaration;

    TemplateDeclaration(SourceLocation loc, PIdentifier name, std::vector<PGenericParameter> parameters, PDeclaration declaration);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```

### 4.32. `TypeNode`

Represents type information in the AST. This is used for type annotations and in type-related expressions.

-   **C++ Class**: `vyn::ast::TypeNode`
-   **`NodeType`**: `TYPE_NODE`
-   **Fields**:
    -   `name` (`std::string`): The name of the type.
    -   `parameters` (`std::vector<PTypeNode>`): Optional type parameters for generic types.

```cpp
// From ast.hpp
class TypeNode : public Node {
public:
    std::string name;
    std::vector<PTypeNode> parameters;

    TypeNode(SourceLocation loc, std::string name, std::vector<PTypeNode> parameters);
    NodeType getType() const override;
    std::string toString() const override;
    void accept(Visitor& visitor) override;
};
```
