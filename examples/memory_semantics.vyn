// Vyn Memory Semantics Examples
// This file demonstrates Vyn's approach to mutability, ownership, and borrowing.

// 1. Basic Declarations: let (mutable) vs. const (immutable)

// `let` declares a mutable variable by default
let mutable_num = 10;
mutable_num = 20; // Allowed

let mutable_str = "hello";
mutable_str = "world"; // Allowed

// `const` declares an immutable constant
const IMMUTABLE_NUM = 100;
// IMMUTABLE_NUM = 200; // Error: Cannot assign to a const variable

const IMMUTABLE_STR = "Vyn";
// IMMUTABLE_STR = "Lang"; // Error: Cannot assign to a const variable

// 2. References: &T (mutable) and &const T (immutable)

// 2.1. Taking references from `let` variables
let x = 5;
let ref_x: &i32 = &x; // Mutable reference to x
*ref_x = 50;          // Modifies x to 50. x is now 50.

let y = 15;
let const_ref_y: &const i32 = &const y; // Immutable reference to y
// *const_ref_y = 150; // Error: Cannot modify through an immutable reference

// You can also take an immutable reference from a mutable variable
let z = 25;
let const_ref_z: &const i32 = &const z;
// *const_ref_z = 250; // Error

// 2.2. Taking references from `const` variables
const A = 75;
// let ref_a: &i32 = &A; // Error: Cannot take a mutable reference from a const variable
let const_ref_a: &const i32 = &const A; // Allowed
// *const_ref_a = 750; // Error: Cannot modify through an immutable reference

// 3. Structs and Mutability

struct Point {
    let x: i32; // Mutable field by default
    let y: i32; // Mutable field by default
    const id: string; // Immutable field
}

// 3.1. Mutable struct instance
let p1 = Point { x: 1, y: 2, id: "p1" };
p1.x = 10; // Allowed, p1 is mutable and p1.x is a `let` field
p1.y = 20; // Allowed

// p1.id = "new_p1_id"; // Error: 'id' is a const field

let ref_p1: &Point = &p1;
ref_p1.x = 100; // Allowed, modifies p1.x

let const_ref_p1: &const Point = &const p1;
// const_ref_p1.x = 1000; // Error: const_ref_p1 is an immutable reference
// const_ref_p1.id = "id"; // Error: id is a const field, and const_ref_p1 is immutable

// 3.2. Const struct instance
const P2 = Point { x: 3, y: 4, id: "p2" };
// P2.x = 30; // Error: P2 is a const variable, cannot modify its fields even if 'x' is `let`
// P2.id = "new_p2_id"; // Error: P2 is const, and 'id' is a const field

let const_ref_p2: &const Point = &const P2;
// const_ref_p2.x = 300; // Error

// 4. Function Parameters

fn modify_value(val_ref: &i32) {
    *val_ref = *val_ref * 2;
}

fn read_value(val_ref: &const i32) {
    let temp = *val_ref + 1; // Reading is fine
    // *val_ref = 0; // Error: Cannot modify through &const
    // print("Read value:", temp);
}

fn modify_point(pt_ref: &Point) {
    pt_ref.x = pt_ref.x + 5;
    pt_ref.y = pt_ref.y + 5;
    // pt_ref.id = "cannot_change"; // Error: id is const
}

fn read_point(pt_ref: &const Point) {
    let new_x = pt_ref.x + 1;
    // pt_ref.x = 0; // Error
    // print("Read point x:", new_x, "id:", pt_ref.id);
}

// Using the functions:
let num_a = 10;
modify_value(&num_a); // num_a becomes 20

let num_b = 30;
read_value(&const num_b);
// read_value(&num_b); // This should also be allowed, taking &const from mutable let

const NUM_C = 40;
read_value(&const NUM_C);
// modify_value(&NUM_C); // Error: Cannot pass &const to &T parameter

let pt_a = Point { x: 1, y: 1, id: "pt_a" };
modify_point(&pt_a); // pt_a.x becomes 6, pt_a.y becomes 6

let pt_b = Point { x: 7, y: 7, id: "pt_b" };
read_point(&const pt_b);

const PT_C = Point { x: 8, y: 8, id: "pt_c" };
read_point(&const PT_C);
// modify_point(&PT_C); // Error

// 5. Mapping Vyn Syntax to VRE Ownership Concepts (my, our, their)

// The VRE uses C++ type aliases `my<T>`, `our<T>`, and `their<T>` for memory management.
// Vyn language constructs map to these concepts as follows:

// 5.1. `my<T>` (Unique Ownership - conceptually std::unique_ptr<T> in C++)
//      Vyn equivalent: `let variable_name = ValueType { ... };`
//      When a variable directly owns a value (i.e., it's not a reference), it's uniquely owned.
//      This is the default behavior for `let` bindings of objects or complex values.
//      The Vyn Runtime Environment (VRE) would manage this with a mechanism equivalent
//      to `my<ValueType>`.

// Example (from earlier in this file, re-iterated for clarity):
// let my_data = Data { val: 1 };
// // In this Vyn code, `my_data` uniquely owns the `Data` instance.
// // Conceptually, in the VRE, this ownership is managed as if by `my<Data>`.

// 5.2. `their<T>` (Non-Owning Borrow - conceptually T* in C++)
//      and `their<const T>` (Non-Owning Immutable Borrow - conceptually const T* in C++)
//      Vyn equivalent: `&T` (mutable borrow) and `&const T` (immutable borrow)
//      References in Vyn (`&` and `&const`) are non-owning pointers to data that is
//      owned elsewhere (e.g., by a `let` binding or another owning structure).
//      - A Vyn `&SomeType` corresponds to `their<SomeType>` in the VRE.
//      - A Vyn `&const SomeType` corresponds to `their<const SomeType>` in the VRE.

// Example (from earlier, re-iterated for clarity):
// let their_data_mut: &Data = &my_data;
// // `their_data_mut` is a non-owning mutable borrow of `my_data`.
// // In the VRE, this reference behaves like `their<Data>`.
//
// let their_data_const: &const Data = &const my_data;
// // `their_data_const` is a non-owning immutable borrow of `my_data`.
// // In the VRE, this reference behaves like `their<const Data>`.

// 5.3. `our<T>` (Shared Ownership - conceptually std::shared_ptr<T> in C++)
//      Vyn equivalent: Currently, Vyn does not have dedicated built-in language
//      syntax for creating shared-ownership smart pointers (like `std::shared_ptr`
//      in C++ or `Rc`/`Arc` in Rust).
//      This functionality would typically be provided by a standard library type
//      (e.g., a `Shared<T>` or `Rc<T>` struct/class) and associated constructor
//      functions (e.g., `Shared::new(...)` or `make_shared(...)`).
//      The VRE would use `our<T>` internally to implement such a library feature.

//      A *hypothetical* Vyn example (IF such a library type `Shared<T>` existed):
//      // fn create_shared_data() -> Shared<Data> {
//      //     return Shared::new(Data { val: 42 });
//      // }
//      // let shared_instance_1 = create_shared_data();
//      // let shared_instance_2 = shared_instance_1.clone(); // Create another reference
//      // // Both `shared_instance_1` and `shared_instance_2` would share ownership.
//      // // In the VRE, this shared state would be managed using `our<Data>`.
//      This is not current Vyn syntax but illustrates the concept.

// Example demonstrating Vyn's current ownership and borrowing:
struct Data { val: i32 }

fn takes_ownership(d: Data) { // d is moved in
    // print("Took ownership of data with val:", d.val);
} // d is dropped here

fn borrows_mutably(d_ref: &Data) {
    d_ref.val = 100;
}

fn borrows_immutably(d_ref: &const Data) {
    // print("Borrowed data immutably with val:", d_ref.val);
}

let my_data = Data { val: 1 }; // `my_data` owns the Data instance

let their_data_mut: &Data = &my_data; // `their_data_mut` borrows `my_data` mutably
borrows_mutably(their_data_mut); // my_data.val is now 100

let their_data_const: &const Data = &const my_data; // `their_data_const` borrows `my_data` immutably
borrows_immutably(their_data_const);

// takes_ownership(my_data); // `my_data` is moved into the function
// print(my_data.val); // Error: my_data has been moved

// Further considerations for future:
// - Lifetimes for references if not inferred.
// - How `my`, `our` might be exposed or managed by the VRE or standard library.
// - Heap allocation syntax (e.g. `box` or `new`).
