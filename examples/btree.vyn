// B-tree implementation in Vyn
// Generic over key (K) and value (V) types, with order M as a compile-time constant

// Assume a Comparable trait for keys
template Comparable
  fn<Bool> lt(const<Self> self, const<their<Self const>> other) -> 
  fn<Bool> eq(const<Self> self, const<their<Self const>> other) -> 

// B-tree template parameterized by key type K, value type V, and order M
template BTree<K: Comparable, V, M: UInt> {
  class Node {
    var<[K; M-1]> keys
    var<[V; M-1]> values
    var<[my<Node>; M]> children
    var<UInt> num_keys
    var<Bool> is_leaf

    fn<Node> new(var<Bool> is_leaf_param) -> { 
      Node {
        keys = [K; M-1](), 
        values = [V; M-1](), 
        children = [my<Node>; M](), 
        num_keys = 0,
        is_leaf = is_leaf_param
      }
    }
  }

  var<my<Node>> root
  var<UInt> size

  fn<BTree<K, V, M>> new() -> 
    const<my<Node>> root_node = make_my(Node::new(true)) 
    BTree { root: root_node, size: 0 }

  fn<Maybe<V>> search(const<Self> self, var<K> key) -> {
    search_node(view self.root, key)
  }

  fn<Maybe<V>> search_node(const<their<Node const>> node, var<K> key) -> {
    if node.num_keys == 0 {
      return None
    }
    const<UInt> idx = find_key_index(node, key)
    if idx < node.num_keys && node.keys[idx].eq(view key) { 
      if node.is_leaf {
        return Some(node.values[idx])
      }
      return if node.children[idx] == nil { None } else { search_node(view node.children[idx], key) }
    }
    if node.is_leaf {
      return None
    }
    return if node.children[idx] == nil { None } else { search_node(view node.children[idx], key) }
  }

  fn<Void> insert(var<Self> self, var<K> key, var<V> value) -> {
    if self.root.num_keys == M-1 {
      const<my<Node>> new_root_node = make_my(Node::new(false))
      new_root_node.children[0] = self.root 
      self.root = new_root_node 
      split_node(borrow self.root, 0)
    }
    insert_non_full(borrow self.root, key, value)
    self.size += 1
  }

  fn<Void> insert_non_full(var<their<Node>> node, var<K> key, var<V> value) -> { 
    var<UInt> idx = find_key_index(view node, key)
    if node.is_leaf {
      for i in (idx..node.num_keys).rev() {
        node.keys[i+1] = node.keys[i]
        node.values[i+1] = node.values[i]
      }
      node.keys[idx] = key
      node.values[idx] = value
      node.num_keys += 1
    } else {
      if node.children[idx] != nil && node.children[idx].num_keys == M-1 {
        split_node(node, idx)
        if key.lt(view node.keys[idx]) {
        } else { 
          idx += 1 
        }
      }
      if node.children[idx] == nil { return } 
      insert_non_full(borrow node.children[idx], key, value)
    }
  }

  fn<Void> split_node(var<their<Node>> parent, var<UInt> child_idx) -> {
    const<their<Node>> full_child = borrow parent.children[child_idx]
    if full_child == nil { return } 

    const<UInt> mid_key_index = (M-1) / 2
    const<my<Node>> new_sibling = make_my(Node::new(full_child.is_leaf))

    var j = 0
    for i in (mid_key_index + 1)..(M-1) {
      new_sibling.keys[j] = full_child.keys[i]
      if full_child.is_leaf { new_sibling.values[j] = full_child.values[i] }
      j += 1
    }
    new_sibling.num_keys = j

    if !full_child.is_leaf {
      j = 0
      for i in (mid_key_index + 1)..M {
        new_sibling.children[j] = full_child.children[i]
        full_child.children[i] = nil 
        j += 1
      }
    }
    
    const<K> median_key = full_child.keys[mid_key_index]
    const<Maybe<V>> median_value = if full_child.is_leaf { Some(full_child.values[mid_key_index]) } else { None }

    full_child.num_keys = mid_key_index

    for i in (child_idx + 1 .. parent.num_keys + 1).rev() {
      parent.children[i+1] = parent.children[i]
    }
    parent.children[child_idx + 1] = new_sibling 

    for i in (child_idx .. parent.num_keys).rev() {
      parent.keys[i+1] = parent.keys[i]
      if parent.is_leaf { parent.values[i+1] = parent.values[i] } 
    }
    parent.keys[child_idx] = median_key
    if !parent.is_leaf && full_child.is_leaf && median_value != None {
        parent.values[child_idx] = median_value.unwrap(); 
    }
    parent.num_keys += 1
  }

  fn<UInt> find_key_index(const<their<Node const>> node, var<K> key) -> {
    var<UInt> idx = 0
    while idx < node.num_keys && node.keys[idx].lt(view key) {
      idx += 1
    }
    return idx 
  }
}

// Example usage
fn<Void> main() -> {
  var<BTree<Int, String, 3>> tree = BTree<Int, String, 3>::new()
  tree.insert(10, "ten")
  tree.insert(20, "twenty")
  tree.insert(5, "five")
  tree.insert(15, "fifteen")
  
  match tree.search(10)
    Some(v) => println("Found: {}", v)
    None => println("Not found")
  
  match tree.search(99) {
    Some(v) => println("Found: {}", v)
    None => println("Not found")
  }